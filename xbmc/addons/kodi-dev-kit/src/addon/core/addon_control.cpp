/*
 *  Copyright (C) 2005-2020 Team Kodi
 *  This file is part of Kodi - https://kodi.tv
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later
 *  See LICENSES/README.md for more information.
 */

#include "addon_control.h"

#include "../../../include/kodi/tools/StringUtils.h"
#include "../../../src/shared/api/processor.h"

/*---AUTO_GEN_PARSE<CONTROL_SOURCE_INCLUDE>---*/
/* Code below autogenerated, see xbmc/addons/kodi-dev-kit/tools/code-generator.py */
#include "api/addon-instance/audiodecoder.h"
#include "api/addon-instance/audioencoder.h"
#include "api/addon-instance/game.h"
#include "api/addon-instance/imagedecoder.h"
#include "api/addon-instance/inputstream.h"
#include "api/addon-instance/peripheral.h"
#include "api/addon-instance/pvr.h"
#include "api/addon-instance/screensaver.h"
#include "api/addon-instance/vfs.h"
#include "api/addon-instance/videocodec.h"
#include "api/addon-instance/visualization.h"
#include "api/addon-instance/web.h"
#include "api/addon_base.h"
#include "api/gui/window.h"
/*---AUTO_GEN_PARSE<CONTROL_SOURCE_INCLUDE_END>---*/

#if defined(TARGET_LINUX)
#include "addon_offscreen_render_base_linux.h"
#else
#error Not supported OS target!
#endif

using namespace KODI::ADDONS::INTERFACE;
using kodi::tools::StringUtils;
using KODI_ADDON::INTERNAL::AddonIfc;
using KODI_ADDON::INTERNAL::CAddonControl;
using KODI_ADDON::INTERNAL::CAddonThreadIfc;

AddonIfc* AddonIfc::g_ifc = nullptr;

CAddonControl::CAddonControl(AddonIfc* ifc)
  : m_ifc(ifc),
    m_mainThreadId(std::this_thread::get_id()),
    m_mainThread(std::make_shared<CAddonThreadIfc>(0, this, ifc->viaMainThread))
{
  /*---AUTO_GEN_PARSE<CONTROL_CLASS_CREATION>---*/
  /* Code below autogenerated, see xbmc/addons/kodi-dev-kit/tools/code-generator.py */
  CHdl_kodi_addon_base_h* addon_base_h = new CHdl_kodi_addon_base_h(m_ifc);
  m_handlers[funcGroup_addon_base_h] = addon_base_h;
  CHdl_kodi_addoninstance_audiodecoder_h* addoninstance_audiodecoder_h =
      new CHdl_kodi_addoninstance_audiodecoder_h(m_ifc);
  m_handlers[funcGroup_addoninstance_audiodecoder_h] = addoninstance_audiodecoder_h;
  CHdl_kodi_addoninstance_audioencoder_h* addoninstance_audioencoder_h =
      new CHdl_kodi_addoninstance_audioencoder_h(m_ifc);
  m_handlers[funcGroup_addoninstance_audioencoder_h] = addoninstance_audioencoder_h;
  CHdl_kodi_addoninstance_game_h* addoninstance_game_h = new CHdl_kodi_addoninstance_game_h(m_ifc);
  m_handlers[funcGroup_addoninstance_game_h] = addoninstance_game_h;
  CHdl_kodi_addoninstance_imagedecoder_h* addoninstance_imagedecoder_h =
      new CHdl_kodi_addoninstance_imagedecoder_h(m_ifc);
  m_handlers[funcGroup_addoninstance_imagedecoder_h] = addoninstance_imagedecoder_h;
  CHdl_kodi_addoninstance_inputstream_h* addoninstance_inputstream_h =
      new CHdl_kodi_addoninstance_inputstream_h(m_ifc);
  m_handlers[funcGroup_addoninstance_inputstream_h] = addoninstance_inputstream_h;
  CHdl_kodi_addoninstance_peripheral_h* addoninstance_peripheral_h =
      new CHdl_kodi_addoninstance_peripheral_h(m_ifc);
  m_handlers[funcGroup_addoninstance_peripheral_h] = addoninstance_peripheral_h;
  CHdl_kodi_addoninstance_pvr_h* addoninstance_pvr_h = new CHdl_kodi_addoninstance_pvr_h(m_ifc);
  m_handlers[funcGroup_addoninstance_pvr_h] = addoninstance_pvr_h;
  CHdl_kodi_addoninstance_screensaver_h* addoninstance_screensaver_h =
      new CHdl_kodi_addoninstance_screensaver_h(m_ifc);
  m_handlers[funcGroup_addoninstance_screensaver_h] = addoninstance_screensaver_h;
  CHdl_kodi_addoninstance_vfs_h* addoninstance_vfs_h = new CHdl_kodi_addoninstance_vfs_h(m_ifc);
  m_handlers[funcGroup_addoninstance_vfs_h] = addoninstance_vfs_h;
  CHdl_kodi_addoninstance_videocodec_h* addoninstance_videocodec_h =
      new CHdl_kodi_addoninstance_videocodec_h(m_ifc);
  m_handlers[funcGroup_addoninstance_videocodec_h] = addoninstance_videocodec_h;
  CHdl_kodi_addoninstance_visualization_h* addoninstance_visualization_h =
      new CHdl_kodi_addoninstance_visualization_h(m_ifc);
  m_handlers[funcGroup_addoninstance_visualization_h] = addoninstance_visualization_h;
  CHdl_kodi_addoninstance_web_h* addoninstance_web_h = new CHdl_kodi_addoninstance_web_h(m_ifc);
  m_handlers[funcGroup_addoninstance_web_h] = addoninstance_web_h;
  CHdl_kodi_gui_window_h* gui_window_h = new CHdl_kodi_gui_window_h(m_ifc);
  m_handlers[funcGroup_gui_window_h] = gui_window_h;

  if (m_ifc->direct != nullptr)
  {
    addon_base_h->InitDirect(&m_ifc->direct->to_addon.addon_base_h);
    addoninstance_audiodecoder_h->InitDirect(&m_ifc->direct->to_addon.addoninstance_audiodecoder_h);
    addoninstance_audioencoder_h->InitDirect(&m_ifc->direct->to_addon.addoninstance_audioencoder_h);
    addoninstance_game_h->InitDirect(&m_ifc->direct->to_addon.addoninstance_game_h);
    addoninstance_imagedecoder_h->InitDirect(&m_ifc->direct->to_addon.addoninstance_imagedecoder_h);
    addoninstance_inputstream_h->InitDirect(&m_ifc->direct->to_addon.addoninstance_inputstream_h);
    addoninstance_peripheral_h->InitDirect(&m_ifc->direct->to_addon.addoninstance_peripheral_h);
    addoninstance_pvr_h->InitDirect(&m_ifc->direct->to_addon.addoninstance_pvr_h);
    addoninstance_screensaver_h->InitDirect(&m_ifc->direct->to_addon.addoninstance_screensaver_h);
    addoninstance_vfs_h->InitDirect(&m_ifc->direct->to_addon.addoninstance_vfs_h);
    addoninstance_videocodec_h->InitDirect(&m_ifc->direct->to_addon.addoninstance_videocodec_h);
    addoninstance_visualization_h->InitDirect(
        &m_ifc->direct->to_addon.addoninstance_visualization_h);
    addoninstance_web_h->InitDirect(&m_ifc->direct->to_addon.addoninstance_web_h);
    gui_window_h->InitDirect(&m_ifc->direct->to_addon.gui_window_h);
  }
  /*---AUTO_GEN_PARSE<CONTROL_CLASS_CREATION_END>---*/

  if (m_ifc->direct != nullptr)
  {
    m_ifc->direct->to_addon.processor_h.thisClassHdl = this;
    m_ifc->direct->to_addon.processor_h.kodi_kill_child = kodi_kill_child;
  }
}

CAddonControl::~CAddonControl()
{
  for (auto& handler : m_handlers)
  {
    delete handler;
  }
}

bool CAddonControl::Create()
{
  m_stackTrace.load_here(32);

  if (!m_mainThread->Create())
    return false;

  return true;
}

std::shared_ptr<CAddonThreadIfc> CAddonControl::GetThreadIfc()
{
  const std::thread::id threadId = std::this_thread::get_id();

  if (m_mainThreadId == threadId)
  {
    return m_mainThread;
  }

  std::unique_lock<std::mutex> lock(m_mutex);

  auto it = std::find_if(m_runningSubThreads.begin(), m_runningSubThreads.end(),
                         [](std::shared_ptr<CAddonThreadIfc> entry) { return !entry->Active(); });
  if (it == m_runningSubThreads.end())
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_processor_CreateForNewThread(m_mainThread->GetID()));
    m_mainThread->SendMessage(funcGroup_Main, kodi_processor_CreateForNewThread, in, out);
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_processor_CreateForNewThread t = ident.get().as<decltype(t)>();
    const std::string identifier = std::get<0>(t);

    auto newIfc = std::make_shared<CAddonThreadIfc>(std::get<1>(t), this, false);
    if (!newIfc->Create())
    {
      return nullptr;
    }
    m_runningSubThreads.emplace(newIfc);
    return newIfc;
  }

  return *it;
}

bool CAddonControl::ProcessOutside()
{
  return GetThreadIfc()->ProcessOutside();
}

bool CAddonControl::FuncCall(int group,
                             int func,
                             const msgpack::unpacked& in,
                             msgpack::sbuffer& out)
{
  if (group == funcGroup_Main)
  {
    switch (func)
    {
      case kodi_processor_KillChild:
      {
        msgChild__IN_kodi_processor_KillChild t = in.get().as<decltype(t)>();
        if (m_ifc->identifier != std::get<0>(t))
        {
          fprintf(stderr, "FATAL: Addon called with invalid identifier to kill!\n");
        }

        m_ifc->killCalled = true;
        m_ifc->m_cv.notify_all();
        // False return here stops the related thread process.
        return false;
      }
      default:
        break;
    }

    return false;
  }

  if (m_handlers[group])
    return m_handlers[group]->HandleMessage(group, func, in, out);

  fprintf(stderr, "FATAL: Addon called with invalid group %i!\n", group);
  return false;
}

void CAddonControl::kodi_kill_child(void* thisClassHdl, const char* uuid)
{
  auto thisClass = reinterpret_cast<CAddonControl*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  if (thisClass->m_ifc->identifier != uuid)
  {
    fprintf(stderr, "FATAL: Addon called with invalid identifier to kill!\n");
  }

  thisClass->m_ifc->killCalled = true;
  thisClass->m_ifc->m_cv.notify_all();
  thisClass->m_mainThread->DestroyReceiver();
}

std::shared_ptr<KODI_ADDON::INTERNAL::IOffsceenRenderBase> CAddonControl::GetOffscreenRenderBase()
{
#if defined(TARGET_LINUX)
  if (!m_offsceenRenderBase)
  {
    m_offsceenRenderBase = std::make_shared<COffsceenRenderBaseLinux>();
    if (!m_offsceenRenderBase->Create())
      fprintf(stderr, "FATAL: Failed to create offscreen rendering base class!\n");
  }

  return m_offsceenRenderBase;

#else
  return nullptr;
#endif
}
