/*
 *  Copyright (C) 2005-2022 Team Kodi
 *  This file is part of Kodi - https://kodi.tv
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later
 *  See LICENSES/README.md for more information.
 */

/* File autogenerated, see xbmc/addons/kodi-dev-kit/tools/code-generator/code_generator.py */

#include "addon_base.h"

#include "include/kodi/tools/StringUtils.h"

// Shared API
#include "src/shared/Instances.h"

// Lib code
#include "core/addon_control.h"

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1_END>---*/

using namespace KODI::ADDONS::INTERFACE;
using namespace KODI_ADDON::INTERNAL;

namespace KODI_ADDON
{
namespace INTERNAL
{

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2_END>---*/

void CHdl_kodi_addon_base_h::InitDirect(directFuncToAddon_addon_base_h* ifcToAddon)
{
  ifcToAddon->thisClassHdl = this;
  ifcToAddon->kodi_addon_create_v1 = kodi_addon_create_v1;
  ifcToAddon->kodi_addon_destroy_v1 = kodi_addon_destroy_v1;
  ifcToAddon->kodi_addon_setting_change_string_v1 = kodi_addon_setting_change_string_v1;
  ifcToAddon->kodi_addon_setting_change_boolean_v1 = kodi_addon_setting_change_boolean_v1;
  ifcToAddon->kodi_addon_setting_change_integer_v1 = kodi_addon_setting_change_integer_v1;
  ifcToAddon->kodi_addon_setting_change_float_v1 = kodi_addon_setting_change_float_v1;
  ifcToAddon->kodi_addon_create_instance_v1 = kodi_addon_create_instance_v1;
  ifcToAddon->kodi_addon_destroy_instance_v1 = kodi_addon_destroy_instance_v1;
  ifcToAddon->kodi_addon_instance_setting_change_string_v1 =
      kodi_addon_instance_setting_change_string_v1;
  ifcToAddon->kodi_addon_instance_setting_change_boolean_v1 =
      kodi_addon_instance_setting_change_boolean_v1;
  ifcToAddon->kodi_addon_instance_setting_change_integer_v1 =
      kodi_addon_instance_setting_change_integer_v1;
  ifcToAddon->kodi_addon_instance_setting_change_float_v1 =
      kodi_addon_instance_setting_change_float_v1;
  ifcToAddon->kodi_addon_instance_create_v1 = kodi_addon_instance_create_v1;
  ifcToAddon->kodi_addon_instance_destroy_v1 = kodi_addon_instance_destroy_v1;
}

#ifndef KODI_INHIBIT_SHARED
bool CHdl_kodi_addon_base_h::HandleMessage(int funcGroup,
                                           int func,
                                           const msgpack::unpacked& in,
                                           msgpack::sbuffer& out)
{
  if (funcGroup != funcGroup_addon_base_h)
    return false;

  switch (func)
  {
    case funcChild_kodi_addon_create_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_CREATE_V1)(const struct KODI_ADDON_INSTANCE_INFO* first_instance, KODI_ADDON_HDL* hdl);
      // Tuple in:          typedef std::tuple<IFC_KODI_ADDON_INSTANCE_INFO> msgChild__IN_kodi_addon_create_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ADDON_STATUS, PtrValue> msgChild_OUT_kodi_addon_create_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_create_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_INSTANCE_INFO first_instance;
      std::get<0>(t).SetCStructure(&first_instance);
      KODI_ADDON_HDL hdl = nullptr;
      enum ADDON_STATUS auto_gen_ret = kodi_addon_create_v1(this, &first_instance, &hdl);

      msgpack::pack(out, msgChild_OUT_kodi_addon_create_v1(auto_gen_ret, PtrValue(hdl)));
      return true;
    }
    case funcChild_kodi_addon_destroy_v1:
    {
      // Original API call: typedef void(ATTR_APIENTRYP PFN_KODI_ADDON_DESTROY_V1)(KODI_ADDON_HDL hdl);
      // Tuple in:          typedef std::tuple<PtrValue> msgChild__IN_kodi_addon_destroy_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgChild_OUT_kodi_addon_destroy_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_destroy_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));

      kodi_addon_destroy_v1(this, auto_gen_hdl);

      return true;
    }
    case funcChild_kodi_addon_setting_change_string_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_SETTING_CHANGE_STRING_V1)(const KODI_ADDON_HDL hdl, const char* name, const char* value);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, std::string> msgChild__IN_kodi_addon_setting_change_string_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_setting_change_string_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_setting_change_string_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      const std::string& name = std::get<1>(t);
      const std::string& value = std::get<2>(t);
      enum ADDON_STATUS auto_gen_ret =
          kodi_addon_setting_change_string_v1(this, auto_gen_hdl, name.c_str(), value.c_str());

      msgpack::pack(out, msgChild_OUT_kodi_addon_setting_change_string_v1(auto_gen_ret));
      return true;
    }
    case funcChild_kodi_addon_setting_change_boolean_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_SETTING_CHANGE_BOOLEAN_V1)(const KODI_ADDON_HDL hdl, const char* name, bool value);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, bool> msgChild__IN_kodi_addon_setting_change_boolean_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_setting_change_boolean_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_setting_change_boolean_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      const std::string& name = std::get<1>(t);
      bool value = std::get<2>(t);
      enum ADDON_STATUS auto_gen_ret =
          kodi_addon_setting_change_boolean_v1(this, auto_gen_hdl, name.c_str(), value);

      msgpack::pack(out, msgChild_OUT_kodi_addon_setting_change_boolean_v1(auto_gen_ret));
      return true;
    }
    case funcChild_kodi_addon_setting_change_integer_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_SETTING_CHANGE_INTEGER_V1)(const KODI_ADDON_HDL hdl, const char* name, int value);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, int> msgChild__IN_kodi_addon_setting_change_integer_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_setting_change_integer_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_setting_change_integer_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      const std::string& name = std::get<1>(t);
      int value = std::get<2>(t);
      enum ADDON_STATUS auto_gen_ret =
          kodi_addon_setting_change_integer_v1(this, auto_gen_hdl, name.c_str(), value);

      msgpack::pack(out, msgChild_OUT_kodi_addon_setting_change_integer_v1(auto_gen_ret));
      return true;
    }
    case funcChild_kodi_addon_setting_change_float_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_SETTING_CHANGE_FLOAT_V1)(const KODI_ADDON_HDL hdl, const char* name, double value);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, double> msgChild__IN_kodi_addon_setting_change_float_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_setting_change_float_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_setting_change_float_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      const std::string& name = std::get<1>(t);
      double value = std::get<2>(t);
      enum ADDON_STATUS auto_gen_ret =
          kodi_addon_setting_change_float_v1(this, auto_gen_hdl, name.c_str(), value);

      msgpack::pack(out, msgChild_OUT_kodi_addon_setting_change_float_v1(auto_gen_ret));
      return true;
    }
    case funcChild_kodi_addon_create_instance_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_CREATE_INSTANCE_V1)(const KODI_ADDON_HDL hdl, const struct KODI_ADDON_INSTANCE_INFO* info, struct KODI_ADDON_INSTANCE_STRUCT* instance);
      // Tuple in:          typedef std::tuple<PtrValue, IFC_KODI_ADDON_INSTANCE_INFO> msgChild__IN_kodi_addon_create_instance_v1; /* OVERRIDE;USE_HAND_MAKE used, set this by hand */
      // Tuple out:         typedef std::tuple<ADDON_STATUS, PtrValue> msgChild_OUT_kodi_addon_create_instance_v1; /* OVERRIDE;USE_HAND_MAKE used, set this by hand */

      /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_CREATE_INSTANCE_V1>---*/
      msgChild__IN_kodi_addon_create_instance_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      KODI_HANDLE addonInstance = nullptr;
      KODI_ADDON_INSTANCE_INFO info; /* CheckAPIUse_WAY_16 (0004) */
      std::get<1>(t).SetCStructure(&info); /* CheckAPIUse_WAY_16 (0004) */
      ADDON_STATUS status =
          kodi_addon_create_instance_v1(this, auto_gen_hdl, &info, &addonInstance);
      msgpack::pack(out,
                    msgChild_OUT_kodi_addon_create_instance_v1(status, PtrValue(addonInstance)));
      /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_CREATE_INSTANCE_V1_END>---*/
      return true;
    }
    case funcChild_kodi_addon_destroy_instance_v1:
    {
      // Original API call: typedef void(ATTR_APIENTRYP PFN_KODI_ADDON_DESTROY_INSTANCE_V1)(const KODI_ADDON_HDL hdl, const struct KODI_ADDON_INSTANCE_INFO* info, const KODI_ADDON_INSTANCE_HDL instance_hdl);
      // Tuple in:          typedef std::tuple<PtrValue, IFC_KODI_ADDON_INSTANCE_INFO, PtrValue> msgChild__IN_kodi_addon_destroy_instance_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgChild_OUT_kodi_addon_destroy_instance_v1; /* Autogenerated */

      /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_DESTROY_INSTANCE_V1>---*/
      msgChild__IN_kodi_addon_destroy_instance_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      KODI_HANDLE instance = reinterpret_cast<KODI_HANDLE>(std::get<2>(t));
      if (instance)
      {
        KODI_ADDON_INSTANCE_INFO info; /* CheckAPIUse_WAY_16 (0004) */
        std::get<1>(t).SetCStructure(&info); /* CheckAPIUse_WAY_16 (0004) */
        kodi_addon_destroy_instance_v1(this, auto_gen_hdl, &info /* CheckAPIUse_WAY_16 (0004) */,
                                       instance
                                       /* CheckAPIUse_WAY_12 (0004) */);
      }

      /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_DESTROY_INSTANCE_V1_END>---*/
      return true;
    }
    case funcChild_kodi_addon_instance_setting_change_string_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_INSTANCE_SETTING_CHANGE_STRING_V1)(const KODI_ADDON_HDL hdl, const KODI_ADDON_INSTANCE_HDL instance_hdl, const char* name, const char* value);
      // Tuple in:          typedef std::tuple<PtrValue, PtrValue, std::string, std::string> msgChild__IN_kodi_addon_instance_setting_change_string_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_instance_setting_change_string_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_instance_setting_change_string_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      KODI_ADDON_INSTANCE_STRUCT* instance_hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_STRUCT*>(std::get<1>(t));
      const std::string& name = std::get<2>(t);
      const std::string& value = std::get<3>(t);
      enum ADDON_STATUS auto_gen_ret = kodi_addon_instance_setting_change_string_v1(
          this, auto_gen_hdl, instance_hdl->hdl, name.c_str(), value.c_str());

      msgpack::pack(out, msgChild_OUT_kodi_addon_instance_setting_change_string_v1(auto_gen_ret));
      return true;
    }
    case funcChild_kodi_addon_instance_setting_change_boolean_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_INSTANCE_SETTING_CHANGE_BOOLEAN_V1)(const KODI_ADDON_HDL hdl, const KODI_ADDON_INSTANCE_HDL instance_hdl, const char* name, bool value);
      // Tuple in:          typedef std::tuple<PtrValue, PtrValue, std::string, bool> msgChild__IN_kodi_addon_instance_setting_change_boolean_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_instance_setting_change_boolean_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_instance_setting_change_boolean_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      KODI_ADDON_INSTANCE_STRUCT* instance_hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_STRUCT*>(std::get<1>(t));
      const std::string& name = std::get<2>(t);
      bool value = std::get<3>(t);
      enum ADDON_STATUS auto_gen_ret = kodi_addon_instance_setting_change_boolean_v1(
          this, auto_gen_hdl, instance_hdl->hdl, name.c_str(), value);

      msgpack::pack(out, msgChild_OUT_kodi_addon_instance_setting_change_boolean_v1(auto_gen_ret));
      return true;
    }
    case funcChild_kodi_addon_instance_setting_change_integer_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_INSTANCE_SETTING_CHANGE_INTEGER_V1)(const KODI_ADDON_HDL hdl, const KODI_ADDON_INSTANCE_HDL instance_hdl, const char* name, int value);
      // Tuple in:          typedef std::tuple<PtrValue, PtrValue, std::string, int> msgChild__IN_kodi_addon_instance_setting_change_integer_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_instance_setting_change_integer_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_instance_setting_change_integer_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      KODI_ADDON_INSTANCE_STRUCT* instance_hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_STRUCT*>(std::get<1>(t));
      const std::string& name = std::get<2>(t);
      int value = std::get<3>(t);
      enum ADDON_STATUS auto_gen_ret = kodi_addon_instance_setting_change_integer_v1(
          this, auto_gen_hdl, instance_hdl->hdl, name.c_str(), value);

      msgpack::pack(out, msgChild_OUT_kodi_addon_instance_setting_change_integer_v1(auto_gen_ret));
      return true;
    }
    case funcChild_kodi_addon_instance_setting_change_float_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_INSTANCE_SETTING_CHANGE_FLOAT_V1)(const KODI_ADDON_HDL hdl, const KODI_ADDON_INSTANCE_HDL instance_hdl, const char* name, double value);
      // Tuple in:          typedef std::tuple<PtrValue, PtrValue, std::string, double> msgChild__IN_kodi_addon_instance_setting_change_float_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_instance_setting_change_float_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_instance_setting_change_float_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      KODI_ADDON_INSTANCE_STRUCT* instance_hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_STRUCT*>(std::get<1>(t));
      const std::string& name = std::get<2>(t);
      double value = std::get<3>(t);
      enum ADDON_STATUS auto_gen_ret = kodi_addon_instance_setting_change_float_v1(
          this, auto_gen_hdl, instance_hdl->hdl, name.c_str(), value);

      msgpack::pack(out, msgChild_OUT_kodi_addon_instance_setting_change_float_v1(auto_gen_ret));
      return true;
    }
    case funcChild_kodi_addon_instance_create_v1:
    {
      // Original API call: typedef KODI_ADDON_INSTANCE_HDL(ATTR_APIENTRYP PFN_KODI_ADDON_INSTANCE_CREATE_V1)(KODI_ADDON_INSTANCE_BACKEND_HDL kodi_hdl);
      // Tuple in:          typedef std::tuple<PtrValue> msgChild__IN_kodi_addon_instance_create_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<PtrValue> msgChild_OUT_kodi_addon_instance_create_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_instance_create_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      KODI_ADDON_INSTANCE_BACKEND_HDL kodi_hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_BACKEND_HDL>(std::get<0>(t));
      KODI_ADDON_INSTANCE_HDL auto_gen_ret = kodi_addon_instance_create_v1(this, kodi_hdl);

      msgpack::pack(out, msgChild_OUT_kodi_addon_instance_create_v1(PtrValue(auto_gen_ret)));
      return true;
    }
    case funcChild_kodi_addon_instance_destroy_v1:
    {
      // Original API call: typedef void(ATTR_APIENTRYP PFN_KODI_ADDON_INSTANCE_DESTROY_V1)(KODI_ADDON_INSTANCE_HDL hdl);
      // Tuple in:          typedef std::tuple<PtrValue> msgChild__IN_kodi_addon_instance_destroy_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgChild_OUT_kodi_addon_instance_destroy_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_instance_destroy_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));

      kodi_addon_instance_destroy_v1(this, auto_gen_hdl);

      return true;
    }
    default:
      break;
  }
  return false;
}
#endif /* !KODI_INHIBIT_SHARED */

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3>---*/

KODI::ADDONS::INTERFACE::DirectAddonIfc* kodi_check_direct_api(int argc, char* argv[])
{
  static const char* value = "--direct-api=";
  static std::string direct_api = "0";

  for (int i = 1; i < argc; ++i)
  {
    if (argv[i] == nullptr)
      break;

    std::string arg = argv[i];
    if (arg.rfind(value, 0) == 0)
    {
      direct_api = arg.substr(strlen(value));
      break;
    }
    else if ((arg == "-d") || (arg == "--direct-api"))
    {
      if (i + 1 < argc) // Make sure we aren't at the end of argv!
      {
        direct_api = argv[++i]; // Increment 'i' so we don't get the argument as the next argv[i].
        break;
      }
    }
  }

  return reinterpret_cast<KODI::ADDONS::INTERFACE::DirectAddonIfc*>(stoull(direct_api, 0, 16));
}

/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3_END>---*/

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_create_v1(
    void* thisClassHdl,
    const struct KODI_ADDON_INSTANCE_INFO* first_instance,
    KODI_ADDON_HDL* hdl) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD=KODI_ADDON_CREATE_V1_2>---*/

  ADDON_STATUS status;
  if (thisClass->m_ifc->functions.types.kodi_addon.v1.create)
  {
    status = thisClass->m_ifc->functions.types.kodi_addon.v1.create(first_instance, hdl);
    thisClass->m_ifc->functions.hdl = *hdl;
  }
  else
    status = ADDON_STATUS_NOT_IMPLEMENTED;
  *hdl = &thisClass->m_ifc->functions;
  return status;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD=KODI_ADDON_CREATE_V1_2_END>---*/
}

void CHdl_kodi_addon_base_h::kodi_addon_destroy_v1(void* thisClassHdl,
                                                   KODI_ADDON_HDL hdl) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  if (union_data->types.kodi_addon.v1.destroy)
  {
    union_data->types.kodi_addon.v1.destroy(union_data->hdl);
  }
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_setting_change_string_v1(
    void* thisClassHdl,
    const KODI_ADDON_HDL hdl,
    const char* name,
    const char* value) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  enum ADDON_STATUS auto_gen_ret = ADDON_STATUS_OK;
  if (union_data->types.kodi_addon.v1.setting_change_string)
  {
    auto_gen_ret =
        union_data->types.kodi_addon.v1.setting_change_string(union_data->hdl, name, value);
  }
  return auto_gen_ret;
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_setting_change_boolean_v1(
    void* thisClassHdl, const KODI_ADDON_HDL hdl, const char* name, bool value) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  enum ADDON_STATUS auto_gen_ret = ADDON_STATUS_OK;
  if (union_data->types.kodi_addon.v1.setting_change_boolean)
  {
    auto_gen_ret =
        union_data->types.kodi_addon.v1.setting_change_boolean(union_data->hdl, name, value);
  }
  return auto_gen_ret;
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_setting_change_integer_v1(
    void* thisClassHdl, const KODI_ADDON_HDL hdl, const char* name, int value) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  enum ADDON_STATUS auto_gen_ret = ADDON_STATUS_OK;
  if (union_data->types.kodi_addon.v1.setting_change_integer)
  {
    auto_gen_ret =
        union_data->types.kodi_addon.v1.setting_change_integer(union_data->hdl, name, value);
  }
  return auto_gen_ret;
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_setting_change_float_v1(
    void* thisClassHdl,
    const KODI_ADDON_HDL hdl,
    const char* name,
    double value) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  enum ADDON_STATUS auto_gen_ret = ADDON_STATUS_OK;
  if (union_data->types.kodi_addon.v1.setting_change_float)
  {
    auto_gen_ret =
        union_data->types.kodi_addon.v1.setting_change_float(union_data->hdl, name, value);
  }
  return auto_gen_ret;
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_create_instance_v1(
    void* thisClassHdl,
    const KODI_ADDON_HDL hdl,
    const struct KODI_ADDON_INSTANCE_INFO* info,
    KODI_HANDLE* instance) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_CREATE_INSTANCE_V1_2>---*/
  // Autogenerated by "Generate_kodi_addon_instance_construct.py", edit this for code changes!
  ADDON_STATUS status;
  UnionAddonFunctions* data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  if (data->types.kodi_addon.v1.create_instance)
  {
    UnionAddonFunctions* instanceStruct = new UnionAddonFunctions();
    instanceStruct->type = info->type;
    instanceStruct->kodi = info->kodi;

    KODI_ADDON_INSTANCE_STRUCT addonInstance;
    addonInstance.dummy = &instanceStruct->types.dummy;

    status = data->types.kodi_addon.v1.create_instance(data->hdl, info, &addonInstance);
    if (!addonInstance.dummy && status == ADDON_STATUS_OK)
    {
      status = ADDON_STATUS_PERMANENT_FAILURE;
    }
    else if (addonInstance.dummy)
    {
      if (info->type == ADDON_INSTANCE_AUDIODECODER)
      {
        if (&instanceStruct->types.kodi_addon_audiodecoder.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_audiodecoder.v1)*>(
                addonInstance.audiodecoder))
          instanceStruct->types.kodi_addon_audiodecoder.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_audiodecoder.v1)*>(
                  addonInstance.audiodecoder);
        if (instanceStruct->types.kodi_addon_audiodecoder.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_audiodecoder.v1.create(instance);
        else
          instanceStruct->hdl = addonInstance.hdl;
        goto done;
      }
      if (info->type == ADDON_INSTANCE_AUDIOENCODER)
      {
        if (&instanceStruct->types.kodi_addon_audioencoder.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_audioencoder.v1)*>(
                addonInstance.audioencoder))
          instanceStruct->types.kodi_addon_audioencoder.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_audioencoder.v1)*>(
                  addonInstance.audioencoder);
        if (instanceStruct->types.kodi_addon_audioencoder.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_audioencoder.v1.create(instance);
        else
          instanceStruct->hdl = addonInstance.hdl;
        goto done;
      }
      if (info->type == ADDON_INSTANCE_GAME)
      {
        if (&instanceStruct->types.kodi_addon_game.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_game.v1)*>(
                addonInstance.game))
          instanceStruct->types.kodi_addon_game.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_game.v1)*>(
                  addonInstance.game);
        if (instanceStruct->types.kodi_addon_game.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_game.v1.create(instance);
        else
          instanceStruct->hdl = addonInstance.hdl;
        goto done;
      }
      if (info->type == ADDON_INSTANCE_IMAGEDECODER)
      {
        if (&instanceStruct->types.kodi_addon_imagedecoder.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_imagedecoder.v1)*>(
                addonInstance.imagedecoder))
          instanceStruct->types.kodi_addon_imagedecoder.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_imagedecoder.v1)*>(
                  addonInstance.imagedecoder);
        if (instanceStruct->types.kodi_addon_imagedecoder.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_imagedecoder.v1.create(instance);
        else
          instanceStruct->hdl = addonInstance.hdl;
        goto done;
      }
      if (info->type == ADDON_INSTANCE_INPUTSTREAM)
      {
        if (&instanceStruct->types.kodi_addon_inputstream.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_inputstream.v1)*>(
                addonInstance.inputstream))
          instanceStruct->types.kodi_addon_inputstream.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_inputstream.v1)*>(
                  addonInstance.inputstream);
        if (instanceStruct->types.kodi_addon_inputstream.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_inputstream.v1.create(instance);
        else
          instanceStruct->hdl = addonInstance.hdl;
        goto done;
      }
      if (info->type == ADDON_INSTANCE_PERIPHERAL)
      {
        if (&instanceStruct->types.kodi_addon_peripheral.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_peripheral.v1)*>(
                addonInstance.peripheral))
          instanceStruct->types.kodi_addon_peripheral.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_peripheral.v1)*>(
                  addonInstance.peripheral);
        if (instanceStruct->types.kodi_addon_peripheral.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_peripheral.v1.create(instance);
        else
          instanceStruct->hdl = addonInstance.hdl;
        goto done;
      }
      if (info->type == ADDON_INSTANCE_SCREENSAVER)
      {
        if (&instanceStruct->types.kodi_addon_screensaver.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_screensaver.v1)*>(
                addonInstance.screensaver))
          instanceStruct->types.kodi_addon_screensaver.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_screensaver.v1)*>(
                  addonInstance.screensaver);
        if (instanceStruct->types.kodi_addon_screensaver.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_screensaver.v1.create(instance);
        else
          instanceStruct->hdl = addonInstance.hdl;
        goto done;
      }
      if (info->type == ADDON_INSTANCE_VFS)
      {
        if (&instanceStruct->types.kodi_addon_vfs.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_vfs.v1)*>(addonInstance.vfs))
          instanceStruct->types.kodi_addon_vfs.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_vfs.v1)*>(
                  addonInstance.vfs);
        if (instanceStruct->types.kodi_addon_vfs.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_vfs.v1.create(instance);
        else
          instanceStruct->hdl = addonInstance.hdl;
        goto done;
      }
      if (info->type == ADDON_INSTANCE_VIDEOCODEC)
      {
        if (&instanceStruct->types.kodi_addon_videocodec.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_videocodec.v1)*>(
                addonInstance.videocodec))
          instanceStruct->types.kodi_addon_videocodec.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_videocodec.v1)*>(
                  addonInstance.videocodec);
        if (instanceStruct->types.kodi_addon_videocodec.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_videocodec.v1.create(instance);
        else
          instanceStruct->hdl = addonInstance.hdl;
        goto done;
      }
      if (info->type == ADDON_INSTANCE_VISUALIZATION)
      {
        if (&instanceStruct->types.kodi_addon_visualization.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_visualization.v1)*>(
                addonInstance.visualization))
          instanceStruct->types.kodi_addon_visualization.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_visualization.v1)*>(
                  addonInstance.visualization);
        if (instanceStruct->types.kodi_addon_visualization.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_visualization.v1.create(instance);
        else
          instanceStruct->hdl = addonInstance.hdl;
        goto done;
      }
      if (info->type == ADDON_INSTANCE_WEB)
      {
        if (&instanceStruct->types.kodi_addon_web.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_web.v1)*>(addonInstance.web))
          instanceStruct->types.kodi_addon_web.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_web.v1)*>(
                  addonInstance.web);
        if (instanceStruct->types.kodi_addon_web.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_web.v1.create(instance);
        else
          instanceStruct->hdl = addonInstance.hdl;
        goto done;
      }
    done:
      *instance = instanceStruct;
      return status;
    }

    delete instanceStruct;
  }
  else
    status = ADDON_STATUS_NOT_IMPLEMENTED;

  return status;
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_CREATE_INSTANCE_V1_2_END>---*/
}

void CHdl_kodi_addon_base_h::kodi_addon_destroy_instance_v1(
    void* thisClassHdl,
    const KODI_ADDON_HDL hdl,
    const struct KODI_ADDON_INSTANCE_INFO* info,
    const KODI_HANDLE instance) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_DESTROY_INSTANCE_V1_2>---*/
  // Autogenerated by "Generate_kodi_addon_instance_construct.py", edit this for code changes!
  UnionAddonFunctions* data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  UnionAddonFunctions* instanceStruct = reinterpret_cast<UnionAddonFunctions*>(instance);
  if (instanceStruct)
  {
    if (info->type == ADDON_INSTANCE_AUDIODECODER)
    {
      if (instanceStruct->types.kodi_addon_audiodecoder.v1.destroy)
        instanceStruct->types.kodi_addon_audiodecoder.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (info->type == ADDON_INSTANCE_AUDIOENCODER)
    {
      if (instanceStruct->types.kodi_addon_audioencoder.v1.destroy)
        instanceStruct->types.kodi_addon_audioencoder.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (info->type == ADDON_INSTANCE_GAME)
    {
      if (instanceStruct->types.kodi_addon_game.v1.destroy)
        instanceStruct->types.kodi_addon_game.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (info->type == ADDON_INSTANCE_IMAGEDECODER)
    {
      if (instanceStruct->types.kodi_addon_imagedecoder.v1.destroy)
        instanceStruct->types.kodi_addon_imagedecoder.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (info->type == ADDON_INSTANCE_INPUTSTREAM)
    {
      if (instanceStruct->types.kodi_addon_inputstream.v1.destroy)
        instanceStruct->types.kodi_addon_inputstream.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (info->type == ADDON_INSTANCE_PERIPHERAL)
    {
      if (instanceStruct->types.kodi_addon_peripheral.v1.destroy)
        instanceStruct->types.kodi_addon_peripheral.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (info->type == ADDON_INSTANCE_SCREENSAVER)
    {
      if (instanceStruct->types.kodi_addon_screensaver.v1.destroy)
        instanceStruct->types.kodi_addon_screensaver.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (info->type == ADDON_INSTANCE_VFS)
    {
      if (instanceStruct->types.kodi_addon_vfs.v1.destroy)
        instanceStruct->types.kodi_addon_vfs.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (info->type == ADDON_INSTANCE_VIDEOCODEC)
    {
      if (instanceStruct->types.kodi_addon_videocodec.v1.destroy)
        instanceStruct->types.kodi_addon_videocodec.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (info->type == ADDON_INSTANCE_VISUALIZATION)
    {
      if (instanceStruct->types.kodi_addon_visualization.v1.destroy)
        instanceStruct->types.kodi_addon_visualization.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (info->type == ADDON_INSTANCE_WEB)
    {
      if (instanceStruct->types.kodi_addon_web.v1.destroy)
        instanceStruct->types.kodi_addon_web.v1.destroy(instanceStruct->hdl);
      goto done;
    }
  done:
    if (data->types.kodi_addon.v1.destroy_instance)
    {
      data->types.kodi_addon.v1.destroy_instance(data->hdl, info, instanceStruct->hdl);
    }
    delete instanceStruct;
  }
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_DESTROY_INSTANCE_V1_2_END>---*/
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_instance_setting_change_string_v1(
    void* thisClassHdl,
    const KODI_ADDON_HDL hdl,
    const KODI_ADDON_INSTANCE_HDL instance_hdl,
    const char* name,
    const char* value) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  UnionAddonFunctions* instanceStruct = reinterpret_cast<UnionAddonFunctions*>(instance_hdl);
  enum ADDON_STATUS auto_gen_ret = ADDON_STATUS_OK;
  if (union_data->types.kodi_addon.v1.instance_setting_change_string)
  {
    auto_gen_ret = union_data->types.kodi_addon.v1.instance_setting_change_string(
        union_data->hdl, instanceStruct->hdl, name, value);
  }
  return auto_gen_ret;
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_instance_setting_change_boolean_v1(
    void* thisClassHdl,
    const KODI_ADDON_HDL hdl,
    const KODI_ADDON_INSTANCE_HDL instance_hdl,
    const char* name,
    bool value) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  UnionAddonFunctions* instanceStruct = reinterpret_cast<UnionAddonFunctions*>(instance_hdl);
  enum ADDON_STATUS auto_gen_ret = ADDON_STATUS_OK;
  if (union_data->types.kodi_addon.v1.instance_setting_change_boolean)
  {
    auto_gen_ret = union_data->types.kodi_addon.v1.instance_setting_change_boolean(
        union_data->hdl, instanceStruct->hdl, name, value);
  }
  return auto_gen_ret;
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_instance_setting_change_integer_v1(
    void* thisClassHdl,
    const KODI_ADDON_HDL hdl,
    const KODI_ADDON_INSTANCE_HDL instance_hdl,
    const char* name,
    int value) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  UnionAddonFunctions* instanceStruct = reinterpret_cast<UnionAddonFunctions*>(instance_hdl);
  enum ADDON_STATUS auto_gen_ret = ADDON_STATUS_OK;
  if (union_data->types.kodi_addon.v1.instance_setting_change_integer)
  {
    auto_gen_ret = union_data->types.kodi_addon.v1.instance_setting_change_integer(
        union_data->hdl, instanceStruct->hdl, name, value);
  }
  return auto_gen_ret;
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_instance_setting_change_float_v1(
    void* thisClassHdl,
    const KODI_ADDON_HDL hdl,
    const KODI_ADDON_INSTANCE_HDL instance_hdl,
    const char* name,
    double value) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  UnionAddonFunctions* instanceStruct = reinterpret_cast<UnionAddonFunctions*>(instance_hdl);
  enum ADDON_STATUS auto_gen_ret = ADDON_STATUS_OK;
  if (union_data->types.kodi_addon.v1.instance_setting_change_float)
  {
    auto_gen_ret = union_data->types.kodi_addon.v1.instance_setting_change_float(
        union_data->hdl, instanceStruct->hdl, name, value);
  }
  return auto_gen_ret;
}

KODI_ADDON_INSTANCE_HDL CHdl_kodi_addon_base_h::kodi_addon_instance_create_v1(
    void* thisClassHdl, KODI_ADDON_INSTANCE_BACKEND_HDL kodi_hdl) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(kodi_hdl);
  KODI_ADDON_INSTANCE_HDL auto_gen_ret = nullptr;
  if (union_data->types.kodi_addon_instance.v1.create)
  {
    auto_gen_ret = union_data->types.kodi_addon_instance.v1.create(kodi_hdl);
  }
  return auto_gen_ret;
}

void CHdl_kodi_addon_base_h::kodi_addon_instance_destroy_v1(
    void* thisClassHdl, KODI_ADDON_INSTANCE_HDL hdl) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  if (union_data->types.kodi_addon_instance.v1.destroy)
  {
    union_data->types.kodi_addon_instance.v1.destroy(union_data->hdl);
  }
}

} /* namespace INTERNAL */
} /* namespace KODI_ADDON */

ATTR_DLL_EXPORT const char* kodi_check_main_shared(int argc, char* argv[])
{
  // Original API call: ATTR_DLL_EXPORT const char* kodi_check_main_shared(int argc, char* argv[]) __INTRODUCED_IN_KODI(1);
  // Tuple in:          /* NOTE: msgParent__IN_kodi_check_main_shared - Override active to use inside dev-kit library only */
  // Tuple out:         /* NOTE: msgParent_OUT_kodi_check_main_shared - Override active to use inside dev-kit library only */

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_CHECK_MAIN_SHARED_V1>---*/

  static const char* value = "--main-shared=";
  static std::string main_shared;

  for (int i = 0; i < argc; ++i)
  {
    if (argv[i] == nullptr)
      break;

    std::string arg = argv[i];
    if (arg.rfind(value, 0) == 0)
    {
      main_shared = arg.substr(strlen(value));
      break;
    }
    else if ((arg == "-m") || (arg == "--main-shared"))
    {
      if (i + 1 < argc) // Make sure we aren't at the end of argv!
      {
        main_shared = argv[++i]; // Increment 'i' so we don't get the argument as the next argv[i].
        break;
      }
    }
  }

  return main_shared.c_str();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_CHECK_MAIN_SHARED_V1_END>---*/
}

ATTR_DLL_EXPORT KODI_IFC_HDL kodi_init(unsigned int api,
                                       int argc,
                                       char* argv[],
                                       struct KODI_ADDON_FUNC* func,
                                       bool via_main,
                                       bool no_receive)
{
  // Original API call: ATTR_DLL_EXPORT KODI_IFC_HDL kodi_init(unsigned int api, int argc, char* argv[], struct KODI_ADDON_FUNC* func, bool via_main, bool no_receive) __INTRODUCED_IN_KODI(1);
  // Tuple in:          /* NOTE: msgParent__IN_kodi_init - Override active to use inside dev-kit library only */
  // Tuple out:         /* NOTE: msgParent_OUT_kodi_init - Override active to use inside dev-kit library only */

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_INIT_V1>---*/

  if (AddonIfc::g_ifc)
  {
    fprintf(stderr, R"error(
FATAL: This class "CChildProcessor" should only be used one time in App.
       Here becomes a second time called and child app becomes destroyed now.
       Inform developer about this addon to fix it!
    )error");
    exit(1);
  }

  KODI_ADDON::INTERNAL::AddonIfc* ifc = new AddonIfc();
  ifc->api = api;
  ifc->identifier = kodi_check_main_shared(argc, argv);
  if (ifc->identifier.empty())
  {
    fprintf(stderr, "FATAL: Started addon without valid identifier, Addon not usable!\n");
    exit(1);
  }

  //   ifc->kodiFirstInstance = kodi_check_for_first_instance(argc, argv);
  ifc->direct = kodi_check_direct_api(argc, argv);
  if (ifc->direct)
    ifc->direct_used = true;

  if (func)
    ifc->functions.types.kodi_addon.v1 =
        *reinterpret_cast<decltype(ifc->functions.types.kodi_addon.v1)*>(func);
  ifc->viaMainThread = via_main;
  ifc->noReceive = no_receive;
  ifc->control = std::unique_ptr<CAddonControl>(new CAddonControl(ifc));
  if (!ifc->control->Create())
  {
    fprintf(stderr, "FATAL: Started addon without valid identifier, Addon not usable!\n");
    delete ifc;
    exit(1);
  }

  AddonIfc::g_ifc = ifc;
  return AddonIfc::g_ifc;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_INIT_V1_END>---*/
}

ATTR_DLL_EXPORT void kodi_deinit(KODI_IFC_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT void kodi_deinit(KODI_IFC_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          /* NOTE: msgParent__IN_kodi_deinit - Override active to use inside dev-kit library only */
  // Tuple out:         /* NOTE: msgParent_OUT_kodi_deinit - Override active to use inside dev-kit library only */

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_DEINIT_V1>---*/

  if (!AddonIfc::g_ifc)
    return;

  delete AddonIfc::g_ifc;
  AddonIfc::g_ifc = nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_DEINIT_V1_END>---*/
}

ATTR_DLL_EXPORT bool kodi_process(KODI_IFC_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_process(KODI_IFC_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          /* NOTE: msgParent__IN_kodi_process - Override active to use inside dev-kit library only */
  // Tuple out:         /* NOTE: msgParent_OUT_kodi_process - Override active to use inside dev-kit library only */

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_PROCESS_V1>---*/

  if (!AddonIfc::g_ifc)
    return false;
  return AddonIfc::g_ifc->control->ProcessOutside();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_PROCESS_V1_END>---*/
}

ATTR_DLL_EXPORT void kodi_log(enum ADDON_LOG loglevel, const char* format, ...)
{
  // Original API call: ATTR_DLL_EXPORT void kodi_log(enum ADDON_LOG loglevel, const char* format, ...) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<ADDON_LOG, std::string> msgParent__IN_kodi_log_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_log_v1; /* Autogenerated */

  if (format == nullptr)
    return;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    va_list args;
    va_start(args, format);
    const std::string cpp_format = kodi::tools::StringUtils::FormatV(format, args);
    va_end(args);
    msgpack::sbuffer in;
    msgpack::pack(in, msgParent__IN_kodi_log_v1(loglevel, cpp_format));
    AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(funcGroup_addon_base_h,
                                                          funcParent_kodi_log_v1, in);
    return;
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  auto_gen_group.kodi_log_v1(auto_gen_group.thisClassHdl, loglevel, format);
}

ATTR_DLL_EXPORT char* kodi_addon_get_addon_path()
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_addon_path() __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_get_addon_path_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_addon_path_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer out;
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessageOnlyGetReturn(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_addon_path_v1, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_addon_path_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_addon_path_v1(auto_gen_group.thisClassHdl);
}

ATTR_DLL_EXPORT char* kodi_addon_get_lib_path()
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_lib_path() __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_get_lib_path_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_lib_path_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer out;
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessageOnlyGetReturn(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_lib_path_v1, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_lib_path_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_lib_path_v1(auto_gen_group.thisClassHdl);
}

ATTR_DLL_EXPORT char* kodi_addon_get_user_path()
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_user_path() __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_get_user_path_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_user_path_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer out;
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessageOnlyGetReturn(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_user_path_v1, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_user_path_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_user_path_v1(auto_gen_group.thisClassHdl);
}

ATTR_DLL_EXPORT char* kodi_addon_get_temp_path()
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_temp_path() __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_get_temp_path_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_temp_path_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer out;
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessageOnlyGetReturn(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_temp_path_v1, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_temp_path_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_temp_path_v1(auto_gen_group.thisClassHdl);
}

ATTR_DLL_EXPORT char* kodi_addon_localized_string(long label_id)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_addon_localized_string(long label_id) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<long> msgParent__IN_kodi_addon_localized_string_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_localized_string_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_localized_string_v1(label_id));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_localized_string_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_localized_string_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_localized_string_v1(auto_gen_group.thisClassHdl, label_id);
}

ATTR_DLL_EXPORT char* kodi_addon_get_info(const char* id)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_info(const char* id) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_addon_get_info_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_info_v1; /* Autogenerated */

  if (id == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_get_info_v1(id));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_info_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_info_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_info_v1(auto_gen_group.thisClassHdl, id);
}

ATTR_DLL_EXPORT bool kodi_addon_open_settings_dialog()
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_open_settings_dialog() __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_open_settings_dialog_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_open_settings_dialog_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer out;
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessageOnlyGetReturn(
            funcGroup_addon_base_h, funcParent_kodi_addon_open_settings_dialog_v1, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_open_settings_dialog_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_open_settings_dialog_v1(auto_gen_group.thisClassHdl);
}

ATTR_DLL_EXPORT bool kodi_addon_is_setting_using_default(const char* id)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_is_setting_using_default(const char* id) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_addon_is_setting_using_default_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_is_setting_using_default_v1; /* Autogenerated */

  if (id == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_is_setting_using_default_v1(id));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_is_setting_using_default_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_is_setting_using_default_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_is_setting_using_default_v1(auto_gen_group.thisClassHdl, id);
}

ATTR_DLL_EXPORT bool kodi_addon_get_setting_bool(const char* id, bool* value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_get_setting_bool(const char* id, bool* value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, bool> msgParent__IN_kodi_addon_get_setting_bool_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, bool> msgParent_OUT_kodi_addon_get_setting_bool_v1; /* Autogenerated */

  if (id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_get_setting_bool_v1(id, *value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_setting_bool_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_setting_bool_v1 t = ident.get().as<decltype(t)>();

    *value = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_setting_bool_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_get_setting_int(const char* id, int* value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_get_setting_int(const char* id, int* value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, int> msgParent__IN_kodi_addon_get_setting_int_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, int> msgParent_OUT_kodi_addon_get_setting_int_v1; /* Autogenerated */

  if (id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_get_setting_int_v1(id, *value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_setting_int_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_setting_int_v1 t = ident.get().as<decltype(t)>();

    *value = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_setting_int_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_get_setting_float(const char* id, double* value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_get_setting_float(const char* id, double* value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, double> msgParent__IN_kodi_addon_get_setting_float_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, double> msgParent_OUT_kodi_addon_get_setting_float_v1; /* Autogenerated */

  if (id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_get_setting_float_v1(id, *value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_setting_float_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_setting_float_v1 t = ident.get().as<decltype(t)>();

    *value = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_setting_float_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_get_setting_string(const char* id, char** value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_get_setting_string(const char* id, char** value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_addon_get_setting_string_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, std::string> msgParent_OUT_kodi_addon_get_setting_string_v1; /* Autogenerated */

  if (id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_get_setting_string_v1(id));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_setting_string_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_setting_string_v1 t = ident.get().as<decltype(t)>();

    *value = strdup(std::get<1>(t).c_str());
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_setting_string_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_set_setting_bool(const char* id, bool value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_set_setting_bool(const char* id, bool value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, bool> msgParent__IN_kodi_addon_set_setting_bool_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_set_setting_bool_v1; /* Autogenerated */

  if (id == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_set_setting_bool_v1(id, value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_set_setting_bool_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_set_setting_bool_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_set_setting_bool_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_set_setting_int(const char* id, int value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_set_setting_int(const char* id, int value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, int> msgParent__IN_kodi_addon_set_setting_int_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_set_setting_int_v1; /* Autogenerated */

  if (id == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_set_setting_int_v1(id, value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_set_setting_int_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_set_setting_int_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_set_setting_int_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_set_setting_float(const char* id, double value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_set_setting_float(const char* id, double value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, double> msgParent__IN_kodi_addon_set_setting_float_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_set_setting_float_v1; /* Autogenerated */

  if (id == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_set_setting_float_v1(id, value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_set_setting_float_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_set_setting_float_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_set_setting_float_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_set_setting_string(const char* id, const char* value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_set_setting_string(const char* id, const char* value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, std::string> msgParent__IN_kodi_addon_set_setting_string_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_set_setting_string_v1; /* Autogenerated */

  if (id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_set_setting_string_v1(id, value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_set_setting_string_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_set_setting_string_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_set_setting_string_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT char* kodi_addon_instance_get_user_path(const KODI_ADDON_INSTANCE_BACKEND_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_addon_instance_get_user_path(const KODI_ADDON_INSTANCE_BACKEND_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_addon_instance_get_user_path_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_instance_get_user_path_v1; /* Autogenerated */

  if (hdl == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_instance_get_user_path_v1(PtrValue(hdl)));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_instance_get_user_path_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_instance_get_user_path_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_instance_get_user_path_v1(auto_gen_group.thisClassHdl, hdl);
}

ATTR_DLL_EXPORT bool kodi_addon_instance_is_setting_using_default(
    const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_is_setting_using_default( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, std::string> msgParent__IN_kodi_addon_instance_is_setting_using_default_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_instance_is_setting_using_default_v1; /* Autogenerated */

  if (hdl == nullptr || id == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgParent__IN_kodi_addon_instance_is_setting_using_default_v1(PtrValue(hdl), id));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_instance_is_setting_using_default_v1, in,
            out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_instance_is_setting_using_default_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_instance_is_setting_using_default_v1(auto_gen_group.thisClassHdl,
                                                                        hdl, id);
}

ATTR_DLL_EXPORT bool kodi_addon_instance_get_setting_bool(const KODI_ADDON_INSTANCE_BACKEND_HDL hdl,
                                                          const char* id,
                                                          bool* value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_get_setting_bool( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, bool* value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, std::string, bool> msgParent__IN_kodi_addon_instance_get_setting_bool_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, bool> msgParent_OUT_kodi_addon_instance_get_setting_bool_v1; /* Autogenerated */

  if (hdl == nullptr || id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgParent__IN_kodi_addon_instance_get_setting_bool_v1(PtrValue(hdl), id, *value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_instance_get_setting_bool_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_instance_get_setting_bool_v1 t = ident.get().as<decltype(t)>();

    *value = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_instance_get_setting_bool_v1(auto_gen_group.thisClassHdl, hdl,
                                                                id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_instance_get_setting_int(const KODI_ADDON_INSTANCE_BACKEND_HDL hdl,
                                                         const char* id,
                                                         int* value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_get_setting_int( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, int* value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, std::string, int> msgParent__IN_kodi_addon_instance_get_setting_int_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, int> msgParent_OUT_kodi_addon_instance_get_setting_int_v1; /* Autogenerated */

  if (hdl == nullptr || id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgParent__IN_kodi_addon_instance_get_setting_int_v1(PtrValue(hdl), id, *value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_instance_get_setting_int_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_instance_get_setting_int_v1 t = ident.get().as<decltype(t)>();

    *value = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_instance_get_setting_int_v1(auto_gen_group.thisClassHdl, hdl, id,
                                                               value);
}

ATTR_DLL_EXPORT bool kodi_addon_instance_get_setting_float(
    const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, double* value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_get_setting_float( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, double* value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, std::string, double> msgParent__IN_kodi_addon_instance_get_setting_float_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, double> msgParent_OUT_kodi_addon_instance_get_setting_float_v1; /* Autogenerated */

  if (hdl == nullptr || id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(
        in, msgParent__IN_kodi_addon_instance_get_setting_float_v1(PtrValue(hdl), id, *value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_instance_get_setting_float_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_instance_get_setting_float_v1 t = ident.get().as<decltype(t)>();

    *value = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_instance_get_setting_float_v1(auto_gen_group.thisClassHdl, hdl,
                                                                 id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_instance_get_setting_string(
    const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, char** value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_get_setting_string( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, char** value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, std::string> msgParent__IN_kodi_addon_instance_get_setting_string_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, std::string> msgParent_OUT_kodi_addon_instance_get_setting_string_v1; /* Autogenerated */

  if (hdl == nullptr || id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_instance_get_setting_string_v1(PtrValue(hdl), id));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_instance_get_setting_string_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_instance_get_setting_string_v1 t = ident.get().as<decltype(t)>();

    *value = strdup(std::get<1>(t).c_str());
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_instance_get_setting_string_v1(auto_gen_group.thisClassHdl, hdl,
                                                                  id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_instance_set_setting_bool(const KODI_ADDON_INSTANCE_BACKEND_HDL hdl,
                                                          const char* id,
                                                          bool value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_set_setting_bool( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, bool value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, std::string, bool> msgParent__IN_kodi_addon_instance_set_setting_bool_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_instance_set_setting_bool_v1; /* Autogenerated */

  if (hdl == nullptr || id == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgParent__IN_kodi_addon_instance_set_setting_bool_v1(PtrValue(hdl), id, value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_instance_set_setting_bool_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_instance_set_setting_bool_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_instance_set_setting_bool_v1(auto_gen_group.thisClassHdl, hdl,
                                                                id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_instance_set_setting_int(const KODI_ADDON_INSTANCE_BACKEND_HDL hdl,
                                                         const char* id,
                                                         int value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_set_setting_int( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, int value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, std::string, int> msgParent__IN_kodi_addon_instance_set_setting_int_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_instance_set_setting_int_v1; /* Autogenerated */

  if (hdl == nullptr || id == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgParent__IN_kodi_addon_instance_set_setting_int_v1(PtrValue(hdl), id, value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_instance_set_setting_int_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_instance_set_setting_int_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_instance_set_setting_int_v1(auto_gen_group.thisClassHdl, hdl, id,
                                                               value);
}

ATTR_DLL_EXPORT bool kodi_addon_instance_set_setting_float(
    const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, double value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_set_setting_float( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, double value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, std::string, double> msgParent__IN_kodi_addon_instance_set_setting_float_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_instance_set_setting_float_v1; /* Autogenerated */

  if (hdl == nullptr || id == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgParent__IN_kodi_addon_instance_set_setting_float_v1(PtrValue(hdl), id, value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_instance_set_setting_float_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_instance_set_setting_float_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_instance_set_setting_float_v1(auto_gen_group.thisClassHdl, hdl,
                                                                 id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_instance_set_setting_string(
    const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, const char* value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_set_setting_string( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, const char* value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, std::string, std::string> msgParent__IN_kodi_addon_instance_set_setting_string_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_instance_set_setting_string_v1; /* Autogenerated */

  if (hdl == nullptr || id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(
        in, msgParent__IN_kodi_addon_instance_set_setting_string_v1(PtrValue(hdl), id, value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_instance_set_setting_string_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_instance_set_setting_string_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_instance_set_setting_string_v1(auto_gen_group.thisClassHdl, hdl,
                                                                  id, value);
}

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_4>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_4_END>---*/
