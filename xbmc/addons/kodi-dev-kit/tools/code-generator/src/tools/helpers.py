# -*- coding: utf-8 -*-

#   Copyright (C) 2021-2022 Team Kodi
#   This file is part of Kodi - https://kodi.tv
#
#   SPDX-License-Identifier: GPL-2.0-or-later
#   See LICENSES/README.md for more information.

# Own includes
from code_generator import DEVKIT_DIR, KODI_DIR, INTERFACE_DIR
from .helper_Log import *
from .sub_file_hdl import *

# Global includes
import glob, os, re

HEADER_FILE_COPYRIGHT = """\
/*
 *  Copyright (C) 2005-""" + str(datetime.now().year) + """ Team Kodi
 *  This file is part of Kodi - https://kodi.tv
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later
 *  See LICENSES/README.md for more information.
 */

/* File autogenerated, see xbmc/addons/kodi-dev-kit/tools/code-generator/code_generator.py */
"""

ignored_FUNCTIONS = [ ]
known_C_STRUCTURES = [ ]


def TranslatePathToCUsableString(path, search_dir):
    return (
        path.replace(search_dir, "")
        .replace(".h", "_h")
        .replace("/", "_")
        .replace("-", "")
        .replace(".in", "")
    )


def FileContainsInterfaceAPICalls(file_path):
    with open(file_path) as f:
        data = f.read()
        for line in data.splitlines():
            if (
                "ATTR_APIENTRYP" in line or "ATTR_DLL_EXPORT" in line
            ) and not "#define" in line:
                return True

    return False


def FileContainsInterfaceAPICallsToAddon(file_path):
  with open(file_path) as f:
    data = f.read()
    f.close()
    for line in data.splitlines():
      if 'ATTR_APIENTRYP' in line and not '#define' in line and not line.strip().startswith('//'):
        return True

  return False


class GetCStruct:
    def __init__(self, name):
        self.entry = ''
        self.code = []
        self.path = ''

        name = name.replace('struct ', '')

        for entry, code, path in known_C_STRUCTURES:
            if entry == name:
                self.entry = entry
                self.code = code
                self.path = path
                return

        search_dir = KODI_DIR + 'xbmc/addons/kodi-dev-kit/include/kodi/c-api/'
        scan_dir = search_dir + '/**/'

        code = []
        dirs = sorted(glob.glob(scan_dir, recursive=True))
        path = ''
        for dir in dirs:
            source_dir = dir.replace(search_dir, '')

            src_parts = sorted(glob.glob(dir + '*.h', recursive=False))
            for src_part in src_parts:
                data = read_file(src_part)
                if not data:
                    Log.PrintResult(Result.FAILURE)
                    Log.PrintFatal("Error: {}".format(code_generator.LAST_ERROR))
                    raise NameError("Dev kit scan failure")

                found = False
                begin_found = False
                in_doc = False
                for line in data.splitlines():
                    if not found and not 'struct' in line:
                        continue
                    code_line = line.strip()
                    if not begin_found and code_line.startswith('{'):
                        begin_found = True
                        continue
                    if code_line == '' or code_line.startswith('//'):
                        continue
                    if code_line.startswith('/*'):
                        in_doc = True
                    if '*/' in code_line:
                        in_doc = False
                        if code_line.endswith("*/"):
                            continue
                        code_line.split("*/")[1]
                    if in_doc:
                        continue

                    if not found:
                        m = re.search('^\ *(?:typedef)?\ *?struct *([a-zA-Z[0-9_]*)$', code_line)
                        if m and m.group(1) and m.group(1) == name:
                            found = True
                            path = src_part
                    else:
                      m = re.search('^\ *}\ *(\ *[a-zA-Z[0-9_]*)\;$', code_line)
                      if m:
                          break
                      code.append(code_line.split(';')[0] + ';')
            if len(code) > 0:
                known_C_STRUCTURES.append((name, code, path))
                self.entry = name
                self.code = code
                self.path = path
                break
        return


def IsIgnoredFunction(name):
  if name in ignored_FUNCTIONS:
    return True

  return False


def CodeGetField_AUTO_GEN_PARSE(target_file, field_name):
  hand_edited = ''
  if os.path.exists(target_file):
    f = open(target_file, 'r')
    data = f.read()
    f.close()
    start = False
    for line in data.splitlines():
      if '/*---AUTO_GEN_PARSE<' + field_name + '>---*/' in line:
        start = True
      elif '/*---AUTO_GEN_PARSE<' + field_name + '_END>---*/' in line:
        start = False
      elif start:
        hand_edited += line + '\n'

    # Fallback for check without version
    if hand_edited == '':
      m = re.search('kodi_.*(_v[0-9]*)$', field_name)
      if m and m.group(1):
        field_name = field_name.replace(m.group(1), '')
        start = False
        for line in data.splitlines():
          if '/*---AUTO_GEN_PARSE<' + field_name + '>---*/' in line:
            start = True
          elif '/*---AUTO_GEN_PARSE<' + field_name + '_END>---*/' in line:
            start = False
          elif start:
            hand_edited += line + '\n'

  return hand_edited

def MakeSpaces(file_text):
  text = ''
  for x in range(len(file_text)+1):
    text += ' '
  return text

def CheckCorrectFunctionValue(value):
  value_reduced = value.replace('*', '').replace('const ', '').replace('long long ', 'long ').strip()
  if '...' in value_reduced:
    return ''
  if len(value_reduced.split()) <= 1:
    return 'No value name present on "{}"'.format(value)
  if '&' in value_reduced:
    return 'C++ pointer set in C function "{}"'.format(value)

  value_reduced = value_reduced.replace('enum ', '').replace('struct ', '')
  if len(value_reduced.split()) <= 1:
    return 'No value name present on "{}"'.format(value)
  return ''


class RegexScanImport:
  def __init__(self, function, options):
    self.function = function
    self.options = options
    self.retval = ''
    self.funcname = ''
    self.values = []
    self.api_added = -1
    self.api_deprecated = -1
    self.api_removed = -1

    self.ifc_name_typedef = ''
    self.ifc_name_func = ''
    self.groupname = ''
    self.funcname_api_lib = ''

  def ScanFunction(self, file_text = ''):
    regex_code = '^typedef\ *(.*)\ ?\(\ *ATTR_APIENTRYP PFN_(.+?)\_V([0-9])\)(?=\()\((.*?)(?=\);|\) *__).+?(|(?:__(DEPRECATED|INTRODUCED|REMOVED)_IN_KODI\(([0-9]+)\))?.?(?:__(DEPRECATED|INTRODUCED|REMOVED)_IN_KODI\(([0-9]+)\))?.(?:__(DEPRECATED|INTRODUCED|REMOVED)_IN_KODI\(([0-9]+)\))(?:[ \t]*));$'
    m = re.search(regex_code, self.function)
    if not m or not m.group(1) or not m.group(2) or not m.group(3) \
       and not m.group(4) and not m.group(6) and not m.group(8):
      Log.PrintResult(Result.FAILURE)
      Log.PrintFatal("ERROR: Function '{}' not match wanted API!".format(self.function))
      raise NameError("Dev kit scan failure")

    self.retval = m.group(1)
    self.funcname = m.group(2).lower()
    self.api_added = int(m.group(3))
    self.api_deprecated = -1
    self.api_removed = -1
    self.values = []
    for value in m.group(4).split(', '):
      if value.strip() != '':
        self.values.append(value.strip())

    if m.group(6) and m.group(6) == 'INTRODUCED':
      self.api_added = int(m.group(7))
    elif m.group(6) and m.group(6) == 'DEPRECATED':
      self.api_deprecated = int(m.group(7))
    elif m.group(6) and m.group(6) == 'REMOVED':
      self.api_removed = int(m.group(7))
    if m.group(8) and m.group(8) == 'INTRODUCED':
      self.api_added = int(m.group(9))
    elif m.group(8) and m.group(8) == 'DEPRECATED':
      self.api_deprecated = int(m.group(9))
    elif m.group(8) and m.group(8) == 'REMOVED':
      self.api_removed = int(m.group(9))
    if m.group(10) and m.group(10) == 'INTRODUCED':
      self.api_added = int(m.group(11))
    elif m.group(10) and m.group(10) == 'DEPRECATED':
      self.api_deprecated = int(m.group(11))
    elif m.group(10) and m.group(10) == 'REMOVED':
      self.api_removed = int(m.group(11))

    self.ifc_name_typedef = 'PFN_{}_V{}'.format(m.group(2), self.api_added)
    for line in file_text.splitlines():
      m = re.search('^\ *' + self.ifc_name_typedef + '\ *([a-z0-9_].*)\;', line)
      if m and m.group(1):
        self.ifc_name_func = m.group(1)
        break

    if self.ifc_name_func != '':
      self.groupname = self.funcname.replace('_' + self.ifc_name_func, '')
    if not self.groupname:
      Log.PrintResult(Result.FAILURE)
      print('FATAL: Can\'t get groupname and function name for:')
      print('       \'{}\''.format(function))
      print('       Have you defined the use of typedef inside function structure?')
      raise NameError('Dev kit scan failure')

    self.funcname_api_lib = '{}_v{}'.format(self.funcname, self.api_added)

    return True


class RegexScanExport:
  def __init__(self, function, options):
    self.function = function
    self.options = options
    self.retval = ''
    self.funcname = ''
    self.values = []
    self.api_added = -1
    self.api_deprecated = -1
    self.api_removed = -1

  def ScanFunction(self, file_text = ''):
    regex_code = '^(?:[ \t]*)?ATTR_DLL_EXPORT[ \t]*(.*)[ \t](kodi.+?)(?=\()\((.*?)(?=\);|\). *__).+?(?:__(DEPRECATED|INTRODUCED|REMOVED)_IN_KODI\(([0-9]+)\))?.?(?:__(DEPRECATED|INTRODUCED|REMOVED)_IN_KODI\(([0-9]+)\))?.(?:__(DEPRECATED|INTRODUCED|REMOVED)_IN_KODI\(([0-9]+)\))(?:[ \t]*);$'
    m = re.search(regex_code, self.function)
    if not m or not m.group(1) or not m.group(2) or not m.group(3) \
       and not m.group(4) and not m.group(6) and not m.group(8):
      Log.PrintResult(Result.FAILURE)
      Log.PrintFatal("ERROR: Function '{}' not match wanted API!".format(self.function))
      raise NameError("Dev kit scan failure")

    self.retval = m.group(1)
    self.funcname = m.group(2)
    self.values = []
    for value in m.group(3).split(', '):
      if value.strip() != '':
        self.values.append(value.strip())

    self.api_added = -1
    self.api_deprecated = -1
    self.api_removed = -1
    if m.group(4) and m.group(4) == 'INTRODUCED':
      self.api_added = int(m.group(5))
    elif m.group(4) and m.group(4) == 'DEPRECATED':
      self.api_deprecated = int(m.group(5))
    elif m.group(4) and m.group(4) == 'REMOVED':
      self.api_removed = int(m.group(5))
    if m.group(6) and m.group(6) == 'INTRODUCED':
      self.api_added = int(m.group(7))
    elif m.group(6) and m.group(6) == 'DEPRECATED':
      self.api_deprecated = int(m.group(7))
    elif m.group(6) and m.group(6) == 'REMOVED':
      self.api_removed = int(m.group(7))
    if m.group(8) and m.group(8) == 'INTRODUCED':
      self.api_added = int(m.group(9))
    elif m.group(8) and m.group(8) == 'DEPRECATED':
      self.api_deprecated = int(m.group(9))
    elif m.group(8) and m.group(8) == 'REMOVED':
      self.api_removed = int(m.group(9))

    return True
