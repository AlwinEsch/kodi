# -*- coding: utf-8 -*-

#   Copyright (C) 2021-2022 Team Kodi
#   This file is part of Kodi - https://kodi.tv
#
#   SPDX-License-Identifier: GPL-2.0-or-later
#   See LICENSES/README.md for more information.

# Own includes
from code_generator import DEVKIT_DIR, KODI_DIR, INTERFACE_DIR
from .tools.helper_Log import *
from .tools.helpers import *
from .tools.sub_file_hdl import *

# Global includes
import glob, os, re, filecmp, shutil


def GenerateSource__XBMC_ADDONS_KODIDEVKIT_SRC_ADDON_CORE_addon_control_cpp(options):
    """
    This function generate automatic code inside xbmc/addons/kodi-dev-kit/src/addon/core/addon_control.cpp.

    Currently it set there the include to all interface parts and his class creations.
    Work code insde must be edited by hand.
    """
    base_dir = "{}/src/addon/".format(DEVKIT_DIR)
    file_name = "{}core/addon_control.cpp".format(base_dir)
    target_file = "{}{}".format(KODI_DIR, file_name)

    Log.PrintBegin("Generate auto code in {}".format(file_name))

    scan_dir = "{}{}api/**/".format(KODI_DIR, base_dir)

    CONTROL_SOURCE_INCLUDE = ""
    CONTROL_CLASS_CREATION = ""
    CONTROL_CLASS_CREATION_2 = ""
    for dir in sorted(glob.glob(scan_dir, recursive=True)):
        # Scan for used headers
        src_parts = sorted(glob.glob("{}*.h*".format(dir), recursive=False))
        for src_part in src_parts:
            src_part = src_part.replace("{}{}".format(KODI_DIR, base_dir), "")

            data = read_file(src_part.replace("api/", "../../include/kodi/c-api/"))
            if not data:
                Log.PrintResult(Result.FAILURE)
                Log.PrintFatal("Error: {}".format(code_generator.LAST_ERROR))
                exit(1)

            if not "ATTR_APIENTRYP" in data:
                continue

            use_string = TranslatePathToCUsableString(src_part, "api/")

            CONTROL_SOURCE_INCLUDE += ('#include "{}"\n'.format(src_part))
            CONTROL_CLASS_CREATION += (
                "  CHdl_kodi_{0}* {0} = new CHdl_kodi_{0}(m_ifc);\n"
                "  m_handlers[funcGroup_{0}] = {0};\n".format(use_string)
            )
            CONTROL_CLASS_CREATION_2 += (
                "    {0}->InitDirect(&m_ifc->direct->to_addon.{0});\n".format(use_string)
            )

    data = read_file(target_file)
    if not data:
        Log.PrintResult(Result.FAILURE)
        Log.PrintFatal("Error: {}".format(code_generator.LAST_ERROR))
        exit(1)

    file_text = ""
    start_1 = False
    start_2 = False
    for line in data.splitlines():
        # Header include
        if "---AUTO_GEN_PARSE<CONTROL_SOURCE_INCLUDE>---" in line:
            file_text += (
                "{}\n"
                "/* Code below autogenerated, see xbmc/addons/kodi-dev-kit/tools/code-generator.py */\n".format(
                    line
                )
            )
            start_1 = True
        elif "---AUTO_GEN_PARSE<CONTROL_SOURCE_INCLUDE_END>---" in line:
            file_text += "{}{}\n".format(CONTROL_SOURCE_INCLUDE, line)
            start_1 = False
        elif start_1:
            continue
        # Class creation
        elif "---AUTO_GEN_PARSE<CONTROL_CLASS_CREATION>---" in line:
            file_text += (
                "{}\n"
                "  /* Code below autogenerated, see xbmc/addons/kodi-dev-kit/tools/code-generator.py */\n".format(
                    line
                )
            )
            start_2 = True
        elif "---AUTO_GEN_PARSE<CONTROL_CLASS_CREATION_END>---" in line:
            file_text += (
                "{}\n"
                "  if (m_ifc->direct != nullptr)\n"
                "  {{\n"
                "{}"
                "  }}\n"
                "{}\n".format(CONTROL_CLASS_CREATION, CONTROL_CLASS_CREATION_2, line)
            )
            start_2 = False
        elif start_2:
            continue
        else:
            file_text += line + "\n"

    if start_1 or start_2:
        Log.PrintResult(Result.FAILURE)
        Log.PrintFatal(
            "ERROR: Needed CONTROL_CLASS_CREATION_END or CONTROL_SOURCE_INCLUDE_END not present in {}".format(
                file_name
            )
        )
        exit(1)

    # Make now the creation and copy of file
    temp_file = target_file.replace("{}xbmc/addons".format(KODI_DIR), "./tmp")
    if not write_file(temp_file, file_text, True):
      Log.PrintResult(Result.FAILURE)
      Log.PrintFatal(
          "Error: {}".format(code_generator.LAST_ERROR)
      )
      exit(1)

    if options.force or not filecmp.cmp(target_file, temp_file):
        shutil.copyfile(temp_file, target_file)
        Log.PrintResult(Result.UPDATE)
    else:
        Log.PrintResult(Result.ALREADY_DONE)
