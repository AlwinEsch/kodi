/*
 *  Copyright (C) 2005-2022 Team Kodi
 *  This file is part of Kodi - https://kodi.tv
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later
 *  See LICENSES/README.md for more information.
 */

/* File autogenerated, see xbmc/addons/kodi-dev-kit/tools/code-generator/code_generator.py */

#include "addon_base.h"

// Shared API
#include "addons/kodi-dev-kit/src/shared/api/addon_base.h"

// Kodi
#include "addons/interface/InstanceHandler.h"
#include "addons/interface/RunningProcess.h"
#include "utils/log.h"

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1>---*/
#include "Application.h"
#include "GUIUserMessages.h"
#include "addons/AddonManager.h"
#include "addons/gui/GUIDialogAddonSettings.h"
#include "addons/settings/AddonSettings.h"
#include "filesystem/Directory.h"
#include "filesystem/File.h"
#include "filesystem/SpecialProtocol.h"
#include "guilib/GUIComponent.h"
#include "guilib/GUIWindowManager.h"
#include "guilib/LocalizeStrings.h"
#include "utils/URIUtils.h"
#include "utils/log.h"
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1_END>---*/

namespace KODI
{
namespace ADDONS
{
namespace INTERFACE
{

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2>---*/

bool CHdl_kodi_addon_base_h::UpdateSettingInActiveDialog(const std::string& addonId,
                                                         const std::string& id,
                                                         const std::string& value)
{
  if (!CServiceBroker::GetGUI()->GetWindowManager().IsWindowActive(WINDOW_DIALOG_ADDON_SETTINGS))
    return false;

  CGUIDialogAddonSettings* dialog =
      CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogAddonSettings>(
          WINDOW_DIALOG_ADDON_SETTINGS);
  if (dialog->GetCurrentAddonID() != addonId)
    return false;

  CGUIMessage message(GUI_MSG_SETTING_UPDATED, 0, 0);
  std::vector<std::string> params;
  params.emplace_back(id);
  params.push_back(value);
  message.SetStringParams(params);
  CServiceBroker::GetGUI()->GetWindowManager().SendThreadMessage(message,
                                                                 WINDOW_DIALOG_ADDON_SETTINGS);

  return true;
}

/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2_END>---*/

void CHdl_kodi_addon_base_h::InitDirect(directFuncToKodi_addon_base_h* ifcToKodi,
                                        directFuncToAddon_addon_base_h* ifcToAddon)
{
  ifcToKodi->thisClassHdl = this;
  m_ifcToAddon = ifcToAddon;
  // Unused "kodi_check_main_shared", done only in addon lib
  // Unused "kodi_init", done only in addon lib
  // Unused "kodi_deinit", done only in addon lib
  // Unused "kodi_process", done only in addon lib
  ifcToKodi->kodi_log_v1 = kodi_log_v1;
  ifcToKodi->kodi_addon_get_addon_path_v1 = kodi_addon_get_addon_path_v1;
  ifcToKodi->kodi_addon_get_lib_path_v1 = kodi_addon_get_lib_path_v1;
  ifcToKodi->kodi_addon_get_user_path_v1 = kodi_addon_get_user_path_v1;
  ifcToKodi->kodi_addon_get_temp_path_v1 = kodi_addon_get_temp_path_v1;
  ifcToKodi->kodi_addon_localized_string_v1 = kodi_addon_localized_string_v1;
  ifcToKodi->kodi_addon_get_info_v1 = kodi_addon_get_info_v1;
  ifcToKodi->kodi_addon_open_settings_dialog_v1 = kodi_addon_open_settings_dialog_v1;
  ifcToKodi->kodi_addon_is_setting_using_default_v1 = kodi_addon_is_setting_using_default_v1;
  ifcToKodi->kodi_addon_get_setting_bool_v1 = kodi_addon_get_setting_bool_v1;
  ifcToKodi->kodi_addon_get_setting_int_v1 = kodi_addon_get_setting_int_v1;
  ifcToKodi->kodi_addon_get_setting_float_v1 = kodi_addon_get_setting_float_v1;
  ifcToKodi->kodi_addon_get_setting_string_v1 = kodi_addon_get_setting_string_v1;
  ifcToKodi->kodi_addon_set_setting_bool_v1 = kodi_addon_set_setting_bool_v1;
  ifcToKodi->kodi_addon_set_setting_int_v1 = kodi_addon_set_setting_int_v1;
  ifcToKodi->kodi_addon_set_setting_float_v1 = kodi_addon_set_setting_float_v1;
  ifcToKodi->kodi_addon_set_setting_string_v1 = kodi_addon_set_setting_string_v1;
  ifcToKodi->kodi_addon_instance_get_user_path_v1 = kodi_addon_instance_get_user_path_v1;
  ifcToKodi->kodi_addon_instance_is_setting_using_default_v1 =
      kodi_addon_instance_is_setting_using_default_v1;
  ifcToKodi->kodi_addon_instance_get_setting_bool_v1 = kodi_addon_instance_get_setting_bool_v1;
  ifcToKodi->kodi_addon_instance_get_setting_int_v1 = kodi_addon_instance_get_setting_int_v1;
  ifcToKodi->kodi_addon_instance_get_setting_float_v1 = kodi_addon_instance_get_setting_float_v1;
  ifcToKodi->kodi_addon_instance_get_setting_string_v1 = kodi_addon_instance_get_setting_string_v1;
  ifcToKodi->kodi_addon_instance_set_setting_bool_v1 = kodi_addon_instance_set_setting_bool_v1;
  ifcToKodi->kodi_addon_instance_set_setting_int_v1 = kodi_addon_instance_set_setting_int_v1;
  ifcToKodi->kodi_addon_instance_set_setting_float_v1 = kodi_addon_instance_set_setting_float_v1;
  ifcToKodi->kodi_addon_instance_set_setting_string_v1 = kodi_addon_instance_set_setting_string_v1;
}

bool CHdl_kodi_addon_base_h::HandleMessage(int funcGroup,
                                           int func,
                                           const msgpack::unpacked& in,
                                           msgpack::sbuffer& out)
{
  if (funcGroup != funcGroup_addon_base_h)
    return false;

  switch (func)
  {
    case funcParent_kodi_log_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_log(enum ADDON_LOG loglevel, const char* format, ...) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<ADDON_LOG, std::string> msgParent__IN_kodi_log_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_log_v1; /* Autogenerated */
      msgParent__IN_kodi_log_v1 t = in.get().as<decltype(t)>();
      enum ADDON_LOG loglevel = std::get<0>(t);
      const std::string& format = std::get<1>(t);
      kodi_log_v1(this, loglevel, format.c_str());
      return true;
    }
    case funcParent_kodi_addon_get_addon_path_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_addon_path() __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_get_addon_path_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_addon_path_v1; /* Autogenerated */
      char* auto_gen_ret = kodi_addon_get_addon_path_v1(this);
      msgpack::pack(out,
                    msgParent_OUT_kodi_addon_get_addon_path_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_addon_get_lib_path_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_lib_path() __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_get_lib_path_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_lib_path_v1; /* Autogenerated */
      char* auto_gen_ret = kodi_addon_get_lib_path_v1(this);
      msgpack::pack(out,
                    msgParent_OUT_kodi_addon_get_lib_path_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_addon_get_user_path_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_user_path() __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_get_user_path_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_user_path_v1; /* Autogenerated */
      char* auto_gen_ret = kodi_addon_get_user_path_v1(this);
      msgpack::pack(out,
                    msgParent_OUT_kodi_addon_get_user_path_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_addon_get_temp_path_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_temp_path() __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_get_temp_path_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_temp_path_v1; /* Autogenerated */
      char* auto_gen_ret = kodi_addon_get_temp_path_v1(this);
      msgpack::pack(out,
                    msgParent_OUT_kodi_addon_get_temp_path_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_addon_localized_string_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_addon_localized_string(long label_id) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<long> msgParent__IN_kodi_addon_localized_string_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_localized_string_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_localized_string_v1 t = in.get().as<decltype(t)>();
      long label_id = std::get<0>(t);
      char* auto_gen_ret = kodi_addon_localized_string_v1(this, label_id);
      msgpack::pack(out,
                    msgParent_OUT_kodi_addon_localized_string_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_addon_get_info_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_info(const char* id) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_addon_get_info_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_info_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_get_info_v1 t = in.get().as<decltype(t)>();
      const std::string& id = std::get<0>(t);
      char* auto_gen_ret = kodi_addon_get_info_v1(this, id.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_addon_get_info_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_addon_open_settings_dialog_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_open_settings_dialog() __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_open_settings_dialog_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_open_settings_dialog_v1; /* Autogenerated */
      bool auto_gen_ret = kodi_addon_open_settings_dialog_v1(this);
      msgpack::pack(out, msgParent_OUT_kodi_addon_open_settings_dialog_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_addon_is_setting_using_default_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_is_setting_using_default(const char* id) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_addon_is_setting_using_default_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_is_setting_using_default_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_is_setting_using_default_v1 t = in.get().as<decltype(t)>();
      const std::string& id = std::get<0>(t);
      bool auto_gen_ret = kodi_addon_is_setting_using_default_v1(this, id.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_addon_is_setting_using_default_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_addon_get_setting_bool_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_get_setting_bool(const char* id, bool* value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, bool> msgParent__IN_kodi_addon_get_setting_bool_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, bool> msgParent_OUT_kodi_addon_get_setting_bool_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_get_setting_bool_v1 t = in.get().as<decltype(t)>();
      const std::string& id = std::get<0>(t);
      bool value = std::get<1>(t);
      bool auto_gen_ret = kodi_addon_get_setting_bool_v1(this, id.c_str(), &value);
      msgpack::pack(out, msgParent_OUT_kodi_addon_get_setting_bool_v1(auto_gen_ret, value));
      return true;
    }
    case funcParent_kodi_addon_get_setting_int_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_get_setting_int(const char* id, int* value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, int> msgParent__IN_kodi_addon_get_setting_int_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, int> msgParent_OUT_kodi_addon_get_setting_int_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_get_setting_int_v1 t = in.get().as<decltype(t)>();
      const std::string& id = std::get<0>(t);
      int value = std::get<1>(t);
      bool auto_gen_ret = kodi_addon_get_setting_int_v1(this, id.c_str(), &value);
      msgpack::pack(out, msgParent_OUT_kodi_addon_get_setting_int_v1(auto_gen_ret, value));
      return true;
    }
    case funcParent_kodi_addon_get_setting_float_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_get_setting_float(const char* id, double* value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, double> msgParent__IN_kodi_addon_get_setting_float_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, double> msgParent_OUT_kodi_addon_get_setting_float_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_get_setting_float_v1 t = in.get().as<decltype(t)>();
      const std::string& id = std::get<0>(t);
      double value = std::get<1>(t);
      bool auto_gen_ret = kodi_addon_get_setting_float_v1(this, id.c_str(), &value);
      msgpack::pack(out, msgParent_OUT_kodi_addon_get_setting_float_v1(auto_gen_ret, value));
      return true;
    }
    case funcParent_kodi_addon_get_setting_string_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_get_setting_string(const char* id, char** value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_addon_get_setting_string_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, std::string> msgParent_OUT_kodi_addon_get_setting_string_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_get_setting_string_v1 t = in.get().as<decltype(t)>();
      const std::string& id = std::get<0>(t);
      char* value = nullptr;
      bool auto_gen_ret = kodi_addon_get_setting_string_v1(this, id.c_str(), &value);
      msgpack::pack(
          out, msgParent_OUT_kodi_addon_get_setting_string_v1(auto_gen_ret, value ? value : ""));
      if (value)
        free(value);
      return true;
    }
    case funcParent_kodi_addon_set_setting_bool_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_set_setting_bool(const char* id, bool value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, bool> msgParent__IN_kodi_addon_set_setting_bool_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_set_setting_bool_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_set_setting_bool_v1 t = in.get().as<decltype(t)>();
      const std::string& id = std::get<0>(t);
      bool value = std::get<1>(t);
      bool auto_gen_ret = kodi_addon_set_setting_bool_v1(this, id.c_str(), value);
      msgpack::pack(out, msgParent_OUT_kodi_addon_set_setting_bool_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_addon_set_setting_int_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_set_setting_int(const char* id, int value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, int> msgParent__IN_kodi_addon_set_setting_int_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_set_setting_int_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_set_setting_int_v1 t = in.get().as<decltype(t)>();
      const std::string& id = std::get<0>(t);
      int value = std::get<1>(t);
      bool auto_gen_ret = kodi_addon_set_setting_int_v1(this, id.c_str(), value);
      msgpack::pack(out, msgParent_OUT_kodi_addon_set_setting_int_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_addon_set_setting_float_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_set_setting_float(const char* id, double value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, double> msgParent__IN_kodi_addon_set_setting_float_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_set_setting_float_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_set_setting_float_v1 t = in.get().as<decltype(t)>();
      const std::string& id = std::get<0>(t);
      double value = std::get<1>(t);
      bool auto_gen_ret = kodi_addon_set_setting_float_v1(this, id.c_str(), value);
      msgpack::pack(out, msgParent_OUT_kodi_addon_set_setting_float_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_addon_set_setting_string_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_set_setting_string(const char* id, const char* value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, std::string> msgParent__IN_kodi_addon_set_setting_string_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_set_setting_string_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_set_setting_string_v1 t = in.get().as<decltype(t)>();
      const std::string& id = std::get<0>(t);
      const std::string& value = std::get<1>(t);
      bool auto_gen_ret = kodi_addon_set_setting_string_v1(this, id.c_str(), value.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_addon_set_setting_string_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_addon_instance_get_user_path_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_addon_instance_get_user_path(const KODI_ADDON_INSTANCE_BACKEND_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_addon_instance_get_user_path_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_instance_get_user_path_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_instance_get_user_path_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_INSTANCE_BACKEND_HDL hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_BACKEND_HDL>(std::get<0>(t));
      char* auto_gen_ret = kodi_addon_instance_get_user_path_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_addon_instance_get_user_path_v1(
                             auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_addon_instance_is_setting_using_default_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_is_setting_using_default( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::string> msgParent__IN_kodi_addon_instance_is_setting_using_default_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_instance_is_setting_using_default_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_instance_is_setting_using_default_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_INSTANCE_BACKEND_HDL hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_BACKEND_HDL>(std::get<0>(t));
      const std::string& id = std::get<1>(t);
      bool auto_gen_ret = kodi_addon_instance_is_setting_using_default_v1(this, hdl, id.c_str());
      msgpack::pack(out,
                    msgParent_OUT_kodi_addon_instance_is_setting_using_default_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_addon_instance_get_setting_bool_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_get_setting_bool( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, bool* value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, bool> msgParent__IN_kodi_addon_instance_get_setting_bool_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, bool> msgParent_OUT_kodi_addon_instance_get_setting_bool_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_instance_get_setting_bool_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_INSTANCE_BACKEND_HDL hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_BACKEND_HDL>(std::get<0>(t));
      const std::string& id = std::get<1>(t);
      bool value = std::get<2>(t);
      bool auto_gen_ret = kodi_addon_instance_get_setting_bool_v1(this, hdl, id.c_str(), &value);
      msgpack::pack(out,
                    msgParent_OUT_kodi_addon_instance_get_setting_bool_v1(auto_gen_ret, value));
      return true;
    }
    case funcParent_kodi_addon_instance_get_setting_int_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_get_setting_int( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, int* value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, int> msgParent__IN_kodi_addon_instance_get_setting_int_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, int> msgParent_OUT_kodi_addon_instance_get_setting_int_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_instance_get_setting_int_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_INSTANCE_BACKEND_HDL hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_BACKEND_HDL>(std::get<0>(t));
      const std::string& id = std::get<1>(t);
      int value = std::get<2>(t);
      bool auto_gen_ret = kodi_addon_instance_get_setting_int_v1(this, hdl, id.c_str(), &value);
      msgpack::pack(out, msgParent_OUT_kodi_addon_instance_get_setting_int_v1(auto_gen_ret, value));
      return true;
    }
    case funcParent_kodi_addon_instance_get_setting_float_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_get_setting_float( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, double* value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, double> msgParent__IN_kodi_addon_instance_get_setting_float_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, double> msgParent_OUT_kodi_addon_instance_get_setting_float_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_instance_get_setting_float_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_INSTANCE_BACKEND_HDL hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_BACKEND_HDL>(std::get<0>(t));
      const std::string& id = std::get<1>(t);
      double value = std::get<2>(t);
      bool auto_gen_ret = kodi_addon_instance_get_setting_float_v1(this, hdl, id.c_str(), &value);
      msgpack::pack(out,
                    msgParent_OUT_kodi_addon_instance_get_setting_float_v1(auto_gen_ret, value));
      return true;
    }
    case funcParent_kodi_addon_instance_get_setting_string_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_get_setting_string( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, char** value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::string> msgParent__IN_kodi_addon_instance_get_setting_string_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, std::string> msgParent_OUT_kodi_addon_instance_get_setting_string_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_instance_get_setting_string_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_INSTANCE_BACKEND_HDL hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_BACKEND_HDL>(std::get<0>(t));
      const std::string& id = std::get<1>(t);
      char* value = nullptr;
      bool auto_gen_ret = kodi_addon_instance_get_setting_string_v1(this, hdl, id.c_str(), &value);
      msgpack::pack(out, msgParent_OUT_kodi_addon_instance_get_setting_string_v1(
                             auto_gen_ret, value ? value : ""));
      if (value)
        free(value);
      return true;
    }
    case funcParent_kodi_addon_instance_set_setting_bool_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_set_setting_bool( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, bool value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, bool> msgParent__IN_kodi_addon_instance_set_setting_bool_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_instance_set_setting_bool_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_instance_set_setting_bool_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_INSTANCE_BACKEND_HDL hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_BACKEND_HDL>(std::get<0>(t));
      const std::string& id = std::get<1>(t);
      bool value = std::get<2>(t);
      bool auto_gen_ret = kodi_addon_instance_set_setting_bool_v1(this, hdl, id.c_str(), value);
      msgpack::pack(out, msgParent_OUT_kodi_addon_instance_set_setting_bool_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_addon_instance_set_setting_int_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_set_setting_int( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, int value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, int> msgParent__IN_kodi_addon_instance_set_setting_int_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_instance_set_setting_int_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_instance_set_setting_int_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_INSTANCE_BACKEND_HDL hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_BACKEND_HDL>(std::get<0>(t));
      const std::string& id = std::get<1>(t);
      int value = std::get<2>(t);
      bool auto_gen_ret = kodi_addon_instance_set_setting_int_v1(this, hdl, id.c_str(), value);
      msgpack::pack(out, msgParent_OUT_kodi_addon_instance_set_setting_int_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_addon_instance_set_setting_float_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_set_setting_float( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, double value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, double> msgParent__IN_kodi_addon_instance_set_setting_float_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_instance_set_setting_float_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_instance_set_setting_float_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_INSTANCE_BACKEND_HDL hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_BACKEND_HDL>(std::get<0>(t));
      const std::string& id = std::get<1>(t);
      double value = std::get<2>(t);
      bool auto_gen_ret = kodi_addon_instance_set_setting_float_v1(this, hdl, id.c_str(), value);
      msgpack::pack(out, msgParent_OUT_kodi_addon_instance_set_setting_float_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_addon_instance_set_setting_string_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_addon_instance_set_setting_string( const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, const char* value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, std::string> msgParent__IN_kodi_addon_instance_set_setting_string_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_instance_set_setting_string_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_instance_set_setting_string_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_INSTANCE_BACKEND_HDL hdl =
          reinterpret_cast<KODI_ADDON_INSTANCE_BACKEND_HDL>(std::get<0>(t));
      const std::string& id = std::get<1>(t);
      const std::string& value = std::get<2>(t);
      bool auto_gen_ret =
          kodi_addon_instance_set_setting_string_v1(this, hdl, id.c_str(), value.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_addon_instance_set_setting_string_v1(auto_gen_ret));
      return true;
    }
    default:
      CLog::Log(LOGERROR,
                "CHdl_kodi_addon_base_h::{}: addon called with unknown function id '{}' on group "
                "'addon_base_h'",
                __func__, func);
  }

  return false;
}

// Function calls from Kodi to addon

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_create_v1(
    const struct KODI_ADDON_INSTANCE_INFO* first_instance, KODI_ADDON_HDL* hdl)
{
  // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_CREATE_V1)(const struct KODI_ADDON_INSTANCE_INFO* first_instance, KODI_ADDON_HDL* hdl);
  // Tuple in:          typedef std::tuple<IFC_KODI_ADDON_INSTANCE_INFO> msgChild__IN_kodi_addon_create_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<ADDON_STATUS, PtrValue> msgChild_OUT_kodi_addon_create_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_create_v1(first_instance));
    if (!m_process->SendMessage(funcGroup_addon_base_h, funcChild_kodi_addon_create_v1, in, out))
      return ADDON_STATUS_OK;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_create_v1 t = ident.get().as<decltype(t)>();
    *hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<1>(t));
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_create_v1(m_ifcToAddon->thisClassHdl, first_instance, hdl);
}

void CHdl_kodi_addon_base_h::kodi_addon_destroy_v1(KODI_ADDON_HDL hdl)
{
  // Original API call: typedef void(ATTR_APIENTRYP PFN_KODI_ADDON_DESTROY_V1)(KODI_ADDON_HDL hdl);
  // Tuple in:          typedef std::tuple<PtrValue> msgChild__IN_kodi_addon_destroy_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<DummyValue> msgChild_OUT_kodi_addon_destroy_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::pack(in, msgChild__IN_kodi_addon_destroy_v1(PtrValue(hdl)));
    m_process->SendMessage(funcGroup_addon_base_h, funcChild_kodi_addon_destroy_v1, in);
    return;
  }
#endif /* !KODI_INHIBIT_SHARED */

  m_ifcToAddon->kodi_addon_destroy_v1(m_ifcToAddon->thisClassHdl, hdl);
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_setting_change_string_v1(
    const KODI_ADDON_HDL hdl, const char* name, const char* value)
{
  // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_SETTING_CHANGE_STRING_V1)(const KODI_ADDON_HDL hdl, const char* name, const char* value);
  // Tuple in:          typedef std::tuple<PtrValue, std::string, std::string> msgChild__IN_kodi_addon_setting_change_string_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_setting_change_string_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_setting_change_string_v1(PtrValue(hdl), name, value));
    if (!m_process->SendMessage(funcGroup_addon_base_h,
                                funcChild_kodi_addon_setting_change_string_v1, in, out))
      return ADDON_STATUS_OK;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_setting_change_string_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_setting_change_string_v1(m_ifcToAddon->thisClassHdl, hdl, name,
                                                           value);
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_setting_change_boolean_v1(
    const KODI_ADDON_HDL hdl, const char* name, bool value)
{
  // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_SETTING_CHANGE_BOOLEAN_V1)(const KODI_ADDON_HDL hdl, const char* name, bool value);
  // Tuple in:          typedef std::tuple<PtrValue, std::string, bool> msgChild__IN_kodi_addon_setting_change_boolean_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_setting_change_boolean_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgChild__IN_kodi_addon_setting_change_boolean_v1(PtrValue(hdl), name, value));
    if (!m_process->SendMessage(funcGroup_addon_base_h,
                                funcChild_kodi_addon_setting_change_boolean_v1, in, out))
      return ADDON_STATUS_OK;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_setting_change_boolean_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_setting_change_boolean_v1(m_ifcToAddon->thisClassHdl, hdl, name,
                                                            value);
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_setting_change_integer_v1(
    const KODI_ADDON_HDL hdl, const char* name, int value)
{
  // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_SETTING_CHANGE_INTEGER_V1)(const KODI_ADDON_HDL hdl, const char* name, int value);
  // Tuple in:          typedef std::tuple<PtrValue, std::string, int> msgChild__IN_kodi_addon_setting_change_integer_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_setting_change_integer_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgChild__IN_kodi_addon_setting_change_integer_v1(PtrValue(hdl), name, value));
    if (!m_process->SendMessage(funcGroup_addon_base_h,
                                funcChild_kodi_addon_setting_change_integer_v1, in, out))
      return ADDON_STATUS_OK;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_setting_change_integer_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_setting_change_integer_v1(m_ifcToAddon->thisClassHdl, hdl, name,
                                                            value);
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_setting_change_float_v1(
    const KODI_ADDON_HDL hdl, const char* name, double value)
{
  // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_SETTING_CHANGE_FLOAT_V1)(const KODI_ADDON_HDL hdl, const char* name, double value);
  // Tuple in:          typedef std::tuple<PtrValue, std::string, double> msgChild__IN_kodi_addon_setting_change_float_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_setting_change_float_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_setting_change_float_v1(PtrValue(hdl), name, value));
    if (!m_process->SendMessage(funcGroup_addon_base_h,
                                funcChild_kodi_addon_setting_change_float_v1, in, out))
      return ADDON_STATUS_OK;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_setting_change_float_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_setting_change_float_v1(m_ifcToAddon->thisClassHdl, hdl, name,
                                                          value);
}

/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD=KODI_ADDON_CREATE_INSTANCE_V1>---*/
enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_create_instance_v1(
    const KODI_ADDON_HDL hdl, const struct KODI_ADDON_INSTANCE_INFO* info, KODI_HANDLE* instance)
{
  // This function is set by "OVERRIDE;USE_HAND_MAKE" and must be complete set here and other places by hand!!!
#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_create_instance_v1(PtrValue(hdl), info));
    if (!m_process->SendMessage(funcGroup_addon_base_h, funcChild_kodi_addon_create_instance_v1, in,
                                out))
      return ADDON_STATUS_UNKNOWN;

    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_create_instance_v1 t = ident.get().as<decltype(t)>();
    *instance = KODI_HANDLE(std::get<1>(t));
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_create_instance_v1(m_ifcToAddon->thisClassHdl, hdl, info,
                                                     instance);
}
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD=KODI_ADDON_CREATE_INSTANCE_V1_END>---*/

/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD=KODI_ADDON_DESTROY_INSTANCE_V1>---*/
void CHdl_kodi_addon_base_h::kodi_addon_destroy_instance_v1(
    const KODI_ADDON_HDL hdl,
    const struct KODI_ADDON_INSTANCE_INFO* info,
    const KODI_HANDLE instance)
{
  // This function is set by "OVERRIDE;USE_HAND_MAKE" and must be complete set here and other places by hand!!!

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::pack(
        in, msgChild__IN_kodi_addon_destroy_instance_v1(PtrValue(hdl), info, PtrValue(instance)));
    m_process->SendMessage(funcGroup_addon_base_h, funcChild_kodi_addon_destroy_instance_v1, in);
    return;
  }
#endif /* !KODI_INHIBIT_SHARED */

  m_ifcToAddon->kodi_addon_destroy_instance_v1(m_ifcToAddon->thisClassHdl, hdl, info, instance);
}
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD=KODI_ADDON_DESTROY_INSTANCE_V1_END>---*/

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_instance_setting_change_string_v1(
    const KODI_ADDON_HDL hdl,
    const KODI_ADDON_INSTANCE_HDL instance_hdl,
    const char* name,
    const char* value)
{
  // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_INSTANCE_SETTING_CHANGE_STRING_V1)(const KODI_ADDON_HDL hdl, const KODI_ADDON_INSTANCE_HDL instance_hdl, const char* name, const char* value);
  // Tuple in:          typedef std::tuple<PtrValue, PtrValue, std::string, std::string> msgChild__IN_kodi_addon_instance_setting_change_string_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_instance_setting_change_string_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_instance_setting_change_string_v1(
                          PtrValue(hdl), PtrValue(instance_hdl), name, value));
    if (!m_process->SendMessage(funcGroup_addon_base_h,
                                funcChild_kodi_addon_instance_setting_change_string_v1, in, out))
      return ADDON_STATUS_OK;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_instance_setting_change_string_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_instance_setting_change_string_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                                    instance_hdl, name, value);
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_instance_setting_change_boolean_v1(
    const KODI_ADDON_HDL hdl,
    const KODI_ADDON_INSTANCE_HDL instance_hdl,
    const char* name,
    bool value)
{
  // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_INSTANCE_SETTING_CHANGE_BOOLEAN_V1)(const KODI_ADDON_HDL hdl, const KODI_ADDON_INSTANCE_HDL instance_hdl, const char* name, bool value);
  // Tuple in:          typedef std::tuple<PtrValue, PtrValue, std::string, bool> msgChild__IN_kodi_addon_instance_setting_change_boolean_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_instance_setting_change_boolean_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_instance_setting_change_boolean_v1(
                          PtrValue(hdl), PtrValue(instance_hdl), name, value));
    if (!m_process->SendMessage(funcGroup_addon_base_h,
                                funcChild_kodi_addon_instance_setting_change_boolean_v1, in, out))
      return ADDON_STATUS_OK;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_instance_setting_change_boolean_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_instance_setting_change_boolean_v1(
      m_ifcToAddon->thisClassHdl, hdl, instance_hdl, name, value);
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_instance_setting_change_integer_v1(
    const KODI_ADDON_HDL hdl,
    const KODI_ADDON_INSTANCE_HDL instance_hdl,
    const char* name,
    int value)
{
  // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_INSTANCE_SETTING_CHANGE_INTEGER_V1)(const KODI_ADDON_HDL hdl, const KODI_ADDON_INSTANCE_HDL instance_hdl, const char* name, int value);
  // Tuple in:          typedef std::tuple<PtrValue, PtrValue, std::string, int> msgChild__IN_kodi_addon_instance_setting_change_integer_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_instance_setting_change_integer_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_instance_setting_change_integer_v1(
                          PtrValue(hdl), PtrValue(instance_hdl), name, value));
    if (!m_process->SendMessage(funcGroup_addon_base_h,
                                funcChild_kodi_addon_instance_setting_change_integer_v1, in, out))
      return ADDON_STATUS_OK;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_instance_setting_change_integer_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_instance_setting_change_integer_v1(
      m_ifcToAddon->thisClassHdl, hdl, instance_hdl, name, value);
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_instance_setting_change_float_v1(
    const KODI_ADDON_HDL hdl,
    const KODI_ADDON_INSTANCE_HDL instance_hdl,
    const char* name,
    double value)
{
  // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_INSTANCE_SETTING_CHANGE_FLOAT_V1)(const KODI_ADDON_HDL hdl, const KODI_ADDON_INSTANCE_HDL instance_hdl, const char* name, double value);
  // Tuple in:          typedef std::tuple<PtrValue, PtrValue, std::string, double> msgChild__IN_kodi_addon_instance_setting_change_float_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_instance_setting_change_float_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_instance_setting_change_float_v1(
                          PtrValue(hdl), PtrValue(instance_hdl), name, value));
    if (!m_process->SendMessage(funcGroup_addon_base_h,
                                funcChild_kodi_addon_instance_setting_change_float_v1, in, out))
      return ADDON_STATUS_OK;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_instance_setting_change_float_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_instance_setting_change_float_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                                   instance_hdl, name, value);
}

KODI_ADDON_INSTANCE_HDL CHdl_kodi_addon_base_h::kodi_addon_instance_create_v1(
    KODI_ADDON_INSTANCE_BACKEND_HDL kodi_hdl)
{
  // Original API call: typedef KODI_ADDON_INSTANCE_HDL(ATTR_APIENTRYP PFN_KODI_ADDON_INSTANCE_CREATE_V1)(KODI_ADDON_INSTANCE_BACKEND_HDL kodi_hdl);
  // Tuple in:          typedef std::tuple<PtrValue> msgChild__IN_kodi_addon_instance_create_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PtrValue> msgChild_OUT_kodi_addon_instance_create_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_instance_create_v1(PtrValue(kodi_hdl)));
    if (!m_process->SendMessage(funcGroup_addon_base_h, funcChild_kodi_addon_instance_create_v1, in,
                                out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_instance_create_v1 t = ident.get().as<decltype(t)>();
    return reinterpret_cast<KODI_ADDON_INSTANCE_HDL>(std::get<0>(t));
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_instance_create_v1(m_ifcToAddon->thisClassHdl, kodi_hdl);
}

void CHdl_kodi_addon_base_h::kodi_addon_instance_destroy_v1(KODI_ADDON_INSTANCE_HDL hdl)
{
  // Original API call: typedef void(ATTR_APIENTRYP PFN_KODI_ADDON_INSTANCE_DESTROY_V1)(KODI_ADDON_INSTANCE_HDL hdl);
  // Tuple in:          typedef std::tuple<PtrValue> msgChild__IN_kodi_addon_instance_destroy_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<DummyValue> msgChild_OUT_kodi_addon_instance_destroy_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::pack(in, msgChild__IN_kodi_addon_instance_destroy_v1(PtrValue(hdl)));
    m_process->SendMessage(funcGroup_addon_base_h, funcChild_kodi_addon_instance_destroy_v1, in);
    return;
  }
#endif /* !KODI_INHIBIT_SHARED */

  m_ifcToAddon->kodi_addon_instance_destroy_v1(m_ifcToAddon->thisClassHdl, hdl);
}

// Callbacks from addon to Kodi

void CHdl_kodi_addon_base_h::kodi_log_v1(void* thisClassHdl,
                                         enum ADDON_LOG loglevel,
                                         const char* format,
                                         ...)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_LOG>---*/

  int kodiLogLevel = LOGNONE;
  switch (loglevel)
  {
    case ADDON_LOG_DEBUG:
      kodiLogLevel = LOGDEBUG;
      break;
    case ADDON_LOG_INFO:
      kodiLogLevel = LOGINFO;
      break;
    case ADDON_LOG_WARNING:
      kodiLogLevel = LOGWARNING;
      break;
    case ADDON_LOG_ERROR:
      kodiLogLevel = LOGERROR;
      break;
    case ADDON_LOG_FATAL:
      kodiLogLevel = LOGFATAL;
      break;
    default:
      kodiLogLevel = LOGDEBUG;
      break;
  }

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();

  CLog::Log(kodiLogLevel, "AddOnLog: {}: {}", addon->ID(), format);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_LOG_END>---*/
}

char* CHdl_kodi_addon_base_h::kodi_addon_get_addon_path_v1(void* thisClassHdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_ADDON_PATH>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();
  return strdup(CSpecialProtocol::TranslatePath(addon->Path()).c_str());

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_ADDON_PATH_END>---*/
}

char* CHdl_kodi_addon_base_h::kodi_addon_get_lib_path_v1(void* thisClassHdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_LIB_PATH>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();
  return strdup(CSpecialProtocol::TranslatePath(addon->Path()).c_str());

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_LIB_PATH_END>---*/
}

char* CHdl_kodi_addon_base_h::kodi_addon_get_user_path_v1(void* thisClassHdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_USER_PATH>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();
  return strdup(CSpecialProtocol::TranslatePath(addon->Profile()).c_str());

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_USER_PATH_END>---*/
}

char* CHdl_kodi_addon_base_h::kodi_addon_get_temp_path_v1(void* thisClassHdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_TEMP_PATH>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();

  std::string tempPath =
      URIUtils::AddFileToFolder(CServiceBroker::GetAddonMgr().GetTempAddonBasePath(), addon->ID());
  tempPath += "-temp";
  XFILE::CDirectory::Create(tempPath);

  return strdup(CSpecialProtocol::TranslatePath(tempPath).c_str());

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_TEMP_PATH_END>---*/
}

char* CHdl_kodi_addon_base_h::kodi_addon_localized_string_v1(void* thisClassHdl, long label_id)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_LOCALIZED_STRING>---*/
  // Code below must be set manually by hand to make work to Kodi

  if (g_application.m_bStop)
    return nullptr;

  std::string label =
      g_localizeStrings.GetAddonString(thisClass->m_process->GetAddonID(), label_id);
  if (label.empty())
    label = g_localizeStrings.Get(label_id);
  char* buffer = strdup(label.c_str());
  return buffer;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_LOCALIZED_STRING_END>---*/
}

char* CHdl_kodi_addon_base_h::kodi_addon_get_info_v1(void* thisClassHdl, const char* id)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_INFO>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();

  std::string str;
  if (StringUtils::CompareNoCase(id, "author") == 0)
    str = addon->Author();
  else if (StringUtils::CompareNoCase(id, "changelog") == 0)
    str = addon->ChangeLog();
  else if (StringUtils::CompareNoCase(id, "description") == 0)
    str = addon->Description();
  else if (StringUtils::CompareNoCase(id, "disclaimer") == 0)
    str = addon->Disclaimer();
  else if (StringUtils::CompareNoCase(id, "fanart") == 0)
    str = addon->FanArt();
  else if (StringUtils::CompareNoCase(id, "icon") == 0)
    str = addon->Icon();
  else if (StringUtils::CompareNoCase(id, "id") == 0)
    str = addon->ID();
  else if (StringUtils::CompareNoCase(id, "name") == 0)
    str = addon->Name();
  else if (StringUtils::CompareNoCase(id, "path") == 0)
    str = addon->Path();
  else if (StringUtils::CompareNoCase(id, "profile") == 0)
    str = addon->Profile();
  else if (StringUtils::CompareNoCase(id, "summary") == 0)
    str = addon->Summary();
  else if (StringUtils::CompareNoCase(id, "type") == 0)
    str = ADDON::CAddonInfo::TranslateType(addon->Type());
  else if (StringUtils::CompareNoCase(id, "version") == 0)
    str = addon->Version().asString();
  else
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} -  add-on '{}' requests invalid id '{}'", __func__,
              addon->ID(), id);
    return nullptr;
  }

  return strdup(str.c_str());

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_INFO_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_open_settings_dialog_v1(void* thisClassHdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_OPEN_SETTINGS_DIALOG>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();
  return CGUIDialogAddonSettings::ShowForAddon(addon);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_OPEN_SETTINGS_DIALOG_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_is_setting_using_default_v1(void* thisClassHdl,
                                                                    const char* id)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_IS_SETTING_USING_DEFAULT>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();
  if (!addon->HasSettings())
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - couldn't get settings for add-on '{}'", __func__,
              addon->ID());
    return false;
  }

  auto setting = addon->GetSettings()->GetSetting(id);
  if (setting == nullptr)
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - can't find setting '{}' in '{}'", __func__, id,
              addon->ID());
    return false;
  }

  return setting->IsDefault();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_IS_SETTING_USING_DEFAULT_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_get_setting_bool_v1(void* thisClassHdl,
                                                            const char* id,
                                                            bool* value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_SETTING_BOOL>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();

  if (!addon->HasSettings())
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - couldn't get settings for add-on '{}'", __func__,
              addon->ID());
    return false;
  }

  auto setting = addon->GetSettings()->GetSetting(id);
  if (setting == nullptr)
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - can't find setting '{}' in '{}'", __func__, id,
              addon->ID());
    return false;
  }

  if (setting->GetType() != SettingType::Boolean)
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - setting '{}' is not a boolean in '{}'", __func__,
              id, addon->ID());
    return false;
  }

  *value = std::static_pointer_cast<CSettingBool>(setting)->GetValue();
  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_SETTING_BOOL_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_get_setting_int_v1(void* thisClassHdl,
                                                           const char* id,
                                                           int* value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_SETTING_INT>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();

  if (!addon->HasSettings())
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - couldn't get settings for add-on '{}'", __func__,
              addon->ID());
    return false;
  }

  auto setting = addon->GetSettings()->GetSetting(id);
  if (setting == nullptr)
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - can't find setting '{}' in '{}'", __func__, id,
              addon->ID());
    return false;
  }

  if (setting->GetType() != SettingType::Integer && setting->GetType() != SettingType::Number)
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - setting '{}' is not a integer in '{}'", __func__,
              id, addon->ID());
    return false;
  }

  if (setting->GetType() == SettingType::Integer)
    *value = std::static_pointer_cast<CSettingInt>(setting)->GetValue();
  else
    *value = static_cast<int>(std::static_pointer_cast<CSettingNumber>(setting)->GetValue());
  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_SETTING_INT_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_get_setting_float_v1(void* thisClassHdl,
                                                             const char* id,
                                                             double* value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_SETTING_FLOAT>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();

  if (!addon->HasSettings())
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - couldn't get settings for add-on '{}'", __func__,
              addon->ID());
    return false;
  }

  auto setting = addon->GetSettings()->GetSetting(id);
  if (setting == nullptr)
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - can't find setting '{}' in '{}'", __func__, id,
              addon->ID());
    return false;
  }

  if (setting->GetType() != SettingType::Number)
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - setting '{}' is not a number in '{}'", __func__,
              id, addon->ID());
    return false;
  }

  *value = std::static_pointer_cast<CSettingNumber>(setting)->GetValue();
  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_SETTING_FLOAT_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_get_setting_string_v1(void* thisClassHdl,
                                                              const char* id,
                                                              char** value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_SETTING_STRING>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();

  if (!addon->HasSettings())
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - couldn't get settings for add-on '{}'", __func__,
              addon->ID());
    return false;
  }

  auto setting = addon->GetSettings()->GetSetting(id);
  if (setting == nullptr)
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - can't find setting '{}' in '{}'", __func__, id,
              addon->ID());
    return false;
  }

  if (setting->GetType() != SettingType::String)
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - setting '{}' is not a string in '{}'", __func__,
              id, addon->ID());
    return false;
  }

  *value = strdup(std::static_pointer_cast<CSettingString>(setting)->GetValue().c_str());
  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_GET_SETTING_STRING_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_set_setting_bool_v1(void* thisClassHdl,
                                                            const char* id,
                                                            bool value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_SET_SETTING_BOOL>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();

  if (UpdateSettingInActiveDialog(addon->ID(), id, StringUtils::Format("%d", value)))
    return true;

  if (!addon->UpdateSettingBool(id, value))
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - invalid setting type", __func__);
    return false;
  }

  addon->SaveSettings();

  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_SET_SETTING_BOOL_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_set_setting_int_v1(void* thisClassHdl,
                                                           const char* id,
                                                           int value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_SET_SETTING_INT>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();

  if (UpdateSettingInActiveDialog(addon->ID(), id, StringUtils::Format("%i", value)))
    return true;

  if (!addon->UpdateSettingInt(id, value))
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - invalid setting type", __func__);
    return false;
  }

  addon->SaveSettings();

  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_SET_SETTING_INT_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_set_setting_float_v1(void* thisClassHdl,
                                                             const char* id,
                                                             double value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_SET_SETTING_FLOAT>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();

  if (UpdateSettingInActiveDialog(addon->ID(), id, StringUtils::Format("%f", value)))
    return true;

  if (!addon->UpdateSettingNumber(id, value))
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - invalid setting type", __func__);
    return false;
  }

  addon->SaveSettings();

  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_SET_SETTING_FLOAT_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_set_setting_string_v1(void* thisClassHdl,
                                                              const char* id,
                                                              const char* value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_SET_SETTING_STRING>---*/

  const std::shared_ptr<ADDON::IAddon> addon = thisClass->m_interface.m_process->GetAddon();

  if (UpdateSettingInActiveDialog(addon->ID(), id, value))
    return true;

  if (!addon->UpdateSettingString(id, value))
  {
    CLog::Log(LOGERROR, "CHdlIn_addon_base_h::{} - invalid setting type", __func__);
    return false;
  }

  addon->SaveSettings();

  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_SET_SETTING_STRING_END>---*/
}

char* CHdl_kodi_addon_base_h::kodi_addon_instance_get_user_path_v1(
    void* thisClassHdl, const KODI_ADDON_INSTANCE_BACKEND_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_GET_USER_PATH>---*/
  // AUTOGENERATED - Used by class "KODI::ADDONS::INTERFACE::IInstanceHandler" with "char* get_instance_user_path()" on "addons/interface/InstanceHandler.h".

  KODI::ADDONS::INTERFACE::IInstanceHandler* cb =
      static_cast<KODI::ADDONS::INTERFACE::IInstanceHandler*>(hdl);
  return cb->get_instance_user_path();
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_GET_USER_PATH_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_instance_is_setting_using_default_v1(
    void* thisClassHdl, const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_IS_SETTING_USING_DEFAULT>---*/
  // AUTOGENERATED - Used by class "KODI::ADDONS::INTERFACE::IInstanceHandler" with "bool is_instance_setting_using_default(const char* id)" on "addons/interface/InstanceHandler.h".

  KODI::ADDONS::INTERFACE::IInstanceHandler* cb =
      static_cast<KODI::ADDONS::INTERFACE::IInstanceHandler*>(hdl);
  return cb->is_instance_setting_using_default(id);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_IS_SETTING_USING_DEFAULT_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_instance_get_setting_bool_v1(
    void* thisClassHdl, const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, bool* value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_GET_SETTING_BOOL>---*/
  // AUTOGENERATED - Used by class "KODI::ADDONS::INTERFACE::IInstanceHandler" with "bool get_instance_setting_bool(const char* id, bool* value)" on "addons/interface/InstanceHandler.h".

  KODI::ADDONS::INTERFACE::IInstanceHandler* cb =
      static_cast<KODI::ADDONS::INTERFACE::IInstanceHandler*>(hdl);
  return cb->get_instance_setting_bool(id, value);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_GET_SETTING_BOOL_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_instance_get_setting_int_v1(
    void* thisClassHdl, const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, int* value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_GET_SETTING_INT>---*/
  // AUTOGENERATED - Used by class "KODI::ADDONS::INTERFACE::IInstanceHandler" with "bool get_instance_setting_int(const char* id, int* value)" on "addons/interface/InstanceHandler.h".

  KODI::ADDONS::INTERFACE::IInstanceHandler* cb =
      static_cast<KODI::ADDONS::INTERFACE::IInstanceHandler*>(hdl);
  return cb->get_instance_setting_int(id, value);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_GET_SETTING_INT_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_instance_get_setting_float_v1(
    void* thisClassHdl, const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, double* value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_GET_SETTING_FLOAT>---*/
  // AUTOGENERATED - Used by class "KODI::ADDONS::INTERFACE::IInstanceHandler" with "bool get_instance_setting_float(const char* id, double* value)" on "addons/interface/InstanceHandler.h".

  KODI::ADDONS::INTERFACE::IInstanceHandler* cb =
      static_cast<KODI::ADDONS::INTERFACE::IInstanceHandler*>(hdl);
  return cb->get_instance_setting_float(id, value);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_GET_SETTING_FLOAT_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_instance_get_setting_string_v1(
    void* thisClassHdl, const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, char** value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_GET_SETTING_STRING>---*/
  // AUTOGENERATED - Used by class "KODI::ADDONS::INTERFACE::IInstanceHandler" with "bool get_instance_setting_string(const char* id, char** value)" on "addons/interface/InstanceHandler.h".

  KODI::ADDONS::INTERFACE::IInstanceHandler* cb =
      static_cast<KODI::ADDONS::INTERFACE::IInstanceHandler*>(hdl);
  return cb->get_instance_setting_string(id, value);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_GET_SETTING_STRING_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_instance_set_setting_bool_v1(
    void* thisClassHdl, const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, bool value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_SET_SETTING_BOOL>---*/
  // AUTOGENERATED - Used by class "KODI::ADDONS::INTERFACE::IInstanceHandler" with "bool set_instance_setting_bool(const char* id, bool value)" on "addons/interface/InstanceHandler.h".

  KODI::ADDONS::INTERFACE::IInstanceHandler* cb =
      static_cast<KODI::ADDONS::INTERFACE::IInstanceHandler*>(hdl);
  return cb->set_instance_setting_bool(id, value);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_SET_SETTING_BOOL_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_instance_set_setting_int_v1(
    void* thisClassHdl, const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, int value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_SET_SETTING_INT>---*/
  // AUTOGENERATED - Used by class "KODI::ADDONS::INTERFACE::IInstanceHandler" with "bool set_instance_setting_int(const char* id, int value)" on "addons/interface/InstanceHandler.h".

  KODI::ADDONS::INTERFACE::IInstanceHandler* cb =
      static_cast<KODI::ADDONS::INTERFACE::IInstanceHandler*>(hdl);
  return cb->set_instance_setting_int(id, value);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_SET_SETTING_INT_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_instance_set_setting_float_v1(
    void* thisClassHdl, const KODI_ADDON_INSTANCE_BACKEND_HDL hdl, const char* id, double value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_SET_SETTING_FLOAT>---*/
  // AUTOGENERATED - Used by class "KODI::ADDONS::INTERFACE::IInstanceHandler" with "bool set_instance_setting_float(const char* id, double value)" on "addons/interface/InstanceHandler.h".

  KODI::ADDONS::INTERFACE::IInstanceHandler* cb =
      static_cast<KODI::ADDONS::INTERFACE::IInstanceHandler*>(hdl);
  return cb->set_instance_setting_float(id, value);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_SET_SETTING_FLOAT_END>---*/
}

bool CHdl_kodi_addon_base_h::kodi_addon_instance_set_setting_string_v1(
    void* thisClassHdl,
    const KODI_ADDON_INSTANCE_BACKEND_HDL hdl,
    const char* id,
    const char* value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_SET_SETTING_STRING>---*/
  // AUTOGENERATED - Used by class "KODI::ADDONS::INTERFACE::IInstanceHandler" with "bool set_instance_setting_string(const char* id, const char* value)" on "addons/interface/InstanceHandler.h".

  KODI::ADDONS::INTERFACE::IInstanceHandler* cb =
      static_cast<KODI::ADDONS::INTERFACE::IInstanceHandler*>(hdl);
  return cb->set_instance_setting_string(id, value);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_INSTANCE_SET_SETTING_STRING_END>---*/
}

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3_END>---*/

} /* namespace INTERFACE */
} /* namespace ADDONS */
} /* namespace KODI */
